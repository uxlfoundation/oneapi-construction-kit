// Copyright (C) Codeplay Software Limited
//
// Licensed under the Apache License, Version 2.0 (the "License") with LLVM
// Exceptions; you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://github.com/codeplaysoftware/oneapi-construction-kit/blob/main/LICENSE.txt
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.
//
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#include <cargo/array_view.h>
#include <cargo/small_vector.h>
#include <cargo/string_algorithm.h>

@generate_includes@

#include <cl/device.h>

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <mutex>

namespace {
cargo::array_view<const extension::extension* const> getExtensions() {
  static cargo::small_vector<const extension::extension*, CA_CL_EXTENSION_COUNT>
      extensions;
  static std::once_flag initialized_flag;
@generate_declarations@

  std::call_once(initialized_flag, []() {
    cargo::result error;
    OCL_UNUSED(error);
@generate_alloc_error@
  });

  return extensions;
}

cargo::array_view<const extension::extension* const> getRuntimeExtensions() {
  static cargo::array_view<const extension::extension* const>
      runtime_extensions{getExtensions().data(), CA_CL_RUNTIME_EXTENSION_COUNT};
  return runtime_extensions;
}

cargo::array_view<const extension::extension* const> getCompilerExtensions() {
  static cargo::array_view<const extension::extension* const>
      compiler_extensions{
          getExtensions().data() + CA_CL_RUNTIME_EXTENSION_COUNT,
          CA_CL_COMPILER_EXTENSION_COUNT};
  return compiler_extensions;
}

void* GetExtensionFunctionAddressForPlatform(
    const size_t num_extensions, const extension::extension* const* extensions,
    cl_platform_id platform, const char* func_name) {
  OCL_ASSERT(
      nullptr != platform,
      "Invalid platform. Expecting caller to map nullptr to a valid platform.");

  if (nullptr == func_name) {
    return nullptr;
  }

  void* function_address = nullptr;
  for (size_t table_idx = 0; table_idx < num_extensions; ++table_idx) {
    function_address =
        extensions[table_idx]->GetExtensionFunctionAddressForPlatform(
            platform, func_name);
    if (nullptr != function_address) {
      // Found a function address for func_name, stop the loop.
      // Check that there aren't multiple extensions using the same func_name
      // because then extension ordering determines discovery. Extension
      // function names should be unique.
      OCL_ASSERT(
          nullptr == GetExtensionFunctionAddressForPlatform(
                         num_extensions - table_idx - 1,
                         extensions + table_idx + 1, platform, func_name),
          "Each extension function must belong to exactly one extension info.");
      break;
    }
  }

  return function_address;
}

template <typename T, typename N, typename F>
inline cl_int GetObjectExtensionInfoSingleValue(
    const size_t num_extensions, const extension::extension* const* extensions,
    T object, N param_name, const size_t param_value_size, void* param_value,
    size_t* param_value_size_ret, F get_info_fn);

template <typename T, typename D, typename N, typename F>
inline cl_int GetObjectDetailExtensionInfoSingleValue(
    const size_t num_extensions, const extension::extension* const* extensions,
    T object, D detail, N param_name, const size_t param_value_size,
    void* param_value, size_t* param_value_size_ret, F get_info_fn);

template <typename T, typename D, typename N, typename F>
inline cl_int GetObjectDetailExtensionInfoSingleInputValue(
    const size_t num_extensions, const extension::extension *const *extensions,
    T object, D detail, N param_name, const size_t input_value_size,
    const void *input_value, const size_t param_value_size, void *param_value,
    size_t *param_value_size_ret, F get_info_fn);

template <typename T, typename N, typename F>
inline cl_int GetObjectExtensionInfoAggregatedCString(
    const size_t num_extensions, const extension::extension* const* extensions,
    T object, N param_name, const size_t param_value_size, void* param_value,
    size_t* param_value_size_ret, const char name_separator, F get_info_fn);

/// @brief Query all passed in extensions via the get_info_fn functor/lambda
/// until one accepts the query.
///
/// If no extension in extensions accepts the param_name query, then
/// CL_INVALID_VALUE is returned.
///
/// @see OpenCL clGet...Info calls for more in-detail explanations of
/// param_name, param_value_size, param_value, param_value_size_ret, and
/// possible return codes.
///
/// @tparam T Type of the OpenCL object, e.g., cl_platform.
/// @tparam N Type of the param_name to query for.
/// @tparam F Type of the function/functor/lambda to use for the query.
/// @param[in] num_extensions Number of extensions to query.
/// @param[in] extensions Contiguous memory area containing num_extensions
/// Extension pointers to query.
/// @param[in] object OpenCL object to query.
/// @param[in] param_name Specific information to query for.
/// @param[in] param_value_size Size of memory area pointed to by param_value.
/// Can be 0 if param_value is nullptr.
/// @param[out] param_value Memory area to store the query result in.
/// @param[out] param_value_size_ret Points to memory area to store the
/// minimally required param_value size in. Can be nullptr.
/// @param[in] get_info_fn Function pointer, functor, or lambda which is called
/// for every extension.
///
/// @return Returns CL_SUCCESS if an extension accepts the param_name query and
/// the supplied argument values. CL_INVALID_VALUE if no extension accepts the
/// param_name query. Other OpenCL error return code if an extension accepts
/// param_name but the supplied argument values are wrong.
template <typename T, typename N, typename F>
cl_int GetObjectExtensionInfoSingleValue(
    const size_t num_extensions, const extension::extension* const* extensions,
    T object, N param_name, const size_t param_value_size, void* param_value,
    size_t* param_value_size_ret, F get_info_fn) {
  cl_int retcode = CL_INVALID_VALUE;
  size_t ext_idx = 0;
  for (ext_idx = 0; ext_idx < num_extensions; ++ext_idx) {
    const cl_int supported_retcode = get_info_fn(
        extensions[ext_idx], object, param_name, 0, nullptr, nullptr);
    if (CL_SUCCESS != supported_retcode) {
      // This extension does not support the info query, keep searching.
      continue;
    }

    // Do query.
    retcode = get_info_fn(extensions[ext_idx], object, param_name,
                          param_value_size, param_value, param_value_size_ret);

    // More than one extension shouldn't support the same info query,
    // otherwise results are order dependent which is confusing.
    OCL_ASSERT(
        CL_SUCCESS != retcode ||
            CL_SUCCESS != GetObjectExtensionInfoSingleValue(
                              num_extensions - ext_idx - 1,
                              extensions + ext_idx + 1, object, param_name, 0,
                              nullptr, nullptr, get_info_fn),
        "More than one extension should not support the same info query, "
        "otherwise results are order dependent which is confusing.");

    // One extension supporting the info query or one error is enough to stop
    // the search.
    break;
  }

  return retcode;
}

/// @brief Query all passed in extensions via the get_info_fn functor/lambda
/// until one accepts the query.
///
/// Query for details from OpenCL objects, e.g., applicable to the following
/// info queries:
/// * clGetProgramBuildInfo
/// * clGetKernelWorkGroupInfo,
/// * clGetKernelArgInfo.
///
/// If no extension in extensions accepts the param_name query, then
/// CL_INVALID_VALUE is returned.
///
/// @see OpenCL clGet...Info calls listed above for more in-detail explanations
/// of param_name, param_value_size, param_value, param_value_size_ret, and
/// possible return codes.
///
/// @tparam T Type of the OpenCL object, e.g., cl_platform.
/// @tparam D Type of the detail info to query for.
/// @tparam N Type of the param_name to query for.
/// @tparam F Type of the function/functor/lambda to use for the
///                  query.
/// @param[in] num_extensions Number of extensions to query.
/// @param[in] extensions Contiguous memory area containing num_extensions
/// Extension pointers to query.
/// @param[in] object OpenCL object to query.
/// @param[in] detail Detail info to query for.
/// @param[in] param_name Specific information to query for.
/// @param[in] param_value_size Size of memory area pointed to by param_value.
/// Can be 0 if param_value is nullptr.
/// @param[out] param_value Memory area to store the query result in.
/// @param[out] param_value_size_ret Points to memory area to store the
/// minimally required param_value size in. Can be nullptr.
/// @param[in] get_info_fn Function pointer, functor, or lambda which is called
/// for every extension.
///
/// @return Returns CL_SUCCESS if an extension accepts the param_name query and
/// the supplied argument values. CL_INVALID_VALUE if no extension accepts the
/// param_name query. Other OpenCL error return code if an extension accepts
/// param_name but the supplied argument values are wrong.
template <typename T, typename D, typename N, typename F>
cl_int GetObjectDetailExtensionInfoSingleValue(
    const size_t num_extensions, const extension::extension* const* extensions,
    T object, D detail, N param_name, const size_t param_value_size,
    void* param_value, size_t* param_value_size_ret, F get_info_fn) {
  cl_int retcode = CL_INVALID_VALUE;
  size_t ext_idx = 0;
  for (ext_idx = 0; ext_idx < num_extensions; ++ext_idx) {
    const cl_int supported_retcode = get_info_fn(
        extensions[ext_idx], object, detail, param_name, 0, nullptr, nullptr);
    if (CL_SUCCESS != supported_retcode) {
      // This extension does not support the info query, keep searching.
      continue;
    }

    // Do query.
    retcode = get_info_fn(extensions[ext_idx], object, detail, param_name,
                          param_value_size, param_value, param_value_size_ret);

    // More than one extension shouldn't support the same info query,
    // otherwise results are order dependent which is confusing.
    OCL_ASSERT(
        CL_SUCCESS != retcode ||
            CL_SUCCESS != GetObjectDetailExtensionInfoSingleValue(
                              num_extensions - ext_idx - 1,
                              extensions + ext_idx + 1, object, detail,
                              param_name, 0, nullptr, nullptr, get_info_fn),
        "More than one extension should not support the same info query, "
        "otherwise results are order dependent which is confusing.");

    // One extension supporting the info query or one error is enough to stop
    // the search.
    break;
  }

  return retcode;
}

/// @brief Query all passed in extensions via the get_info_fn functor/lambda
/// until one accepts the query.
///
/// Query for details from OpenCL objects, e.g., applicable to the following
/// info queries:
/// * clGetKernelSubGroupInfo,
///
/// If no extension in extensions accepts the param_name query, then
/// CL_INVALID_VALUE is returned.
///
/// @see OpenCL clGet...Info calls listed above for more in-detail explanations
/// of param_name, param_value_size, param_value, param_value_size_ret, and
/// possible return codes.
///
/// @tparam T Type of the OpenCL object, e.g., cl_platform.
/// @tparam D Type of the detail info to query for.
/// @tparam N Type of the param_name to query for.
/// @tparam F Type of the function/functor/lambda to use for the
///                  query.
/// @param[in] num_extensions Number of extensions to query.
/// @param[in] extensions Contiguous memory area containing num_extensions
/// Extension pointers to query.
/// @param[in] object OpenCL object to query.
/// @param[in] detail Detail info to query for.
/// @param[in] param_name Specific information to query for.
/// @param[in] param_value_size Size of memory area pointed to by param_value.
/// Can be 0 if param_value is nullptr.
/// @param[out] param_value Memory area to store the query result in.
/// @param[out] param_value_size_ret Points to memory area to store the
/// minimally required param_value size in. Can be nullptr.
/// @param[in] get_info_fn Function pointer, functor, or lambda which is called
/// for every extension.
///
/// @return Returns CL_SUCCESS if an extension accepts the param_name query and
/// the supplied argument values. CL_INVALID_VALUE if no extension accepts the
/// param_name query. Other OpenCL error return code if an extension accepts
/// param_name but the supplied argument values are wrong.
template <typename T, typename D, typename N, typename F>
cl_int GetObjectDetailExtensionInfoSingleInputValue(
    const size_t num_extensions, const extension::extension *const *extensions,
    T object, D detail, N param_name, const size_t input_value_size,
    const void *input_value, const size_t param_value_size, void *param_value,
    size_t *param_value_size_ret, F get_info_fn) {
  cl_int retcode = CL_INVALID_VALUE;
  size_t ext_idx = 0;
  for (ext_idx = 0; ext_idx < num_extensions; ++ext_idx) {
    const cl_int supported_retcode =
        get_info_fn(extensions[ext_idx], object, detail, param_name, 0, nullptr,
                    0, nullptr, nullptr);
    if (CL_SUCCESS != supported_retcode) {
      // This extension does not support the info query, keep searching.
      continue;
    }

    // Do query.
    retcode = get_info_fn(extensions[ext_idx], object, detail, param_name,
                          input_value_size, input_value, param_value_size,
                          param_value, param_value_size_ret);

    // More than one extension shouldn't support the same info query,
    // otherwise results are order dependent which is confusing.
    OCL_ASSERT(
        CL_SUCCESS != retcode ||
            CL_SUCCESS != GetObjectDetailExtensionInfoSingleInputValue(
                              num_extensions - ext_idx - 1,
                              extensions + ext_idx + 1, object, detail,
                              param_name, 0, nullptr, 0, nullptr, nullptr,
                              get_info_fn),
        "More than one extension should not support the same info query, "
        "otherwise results are order dependent which is confusing.");

    // One extension supporting the info query or one error is enough to stop
    // the search.
    break;
  }

  return retcode;
}

/// @brief Query all passed in extensions via the get_info_fn functor/lambda and
/// aggregate the param_value c string into a single c string for all extensions
/// that accept param_name.
///
/// If no extension in extensions accepts the param_name query, then
/// CL_INVALID_VALUE is returned.
///
/// @see OpenCL clGetPlatformInfo for param_name CL_PLATFORM_EXTENSIONS or
/// clGetDeviceInfo calls for param_name CL_DEVICE_EXTENSIONS more in-detail
/// explanations of param_name, param_value_size, param_value,
/// param_value_size_ret, and possible return codes.
///
/// @tparam T Type of the OpenCL object, e.g., cl_platform.
/// @tparam N Type of the param_name to query for.
/// @tparam F Type of the function/functor/lambda to use for the query.
/// @param[in] num_extensions Number of extensions to query.
/// @param[in] extensions Contiguous memory area containing num_extensions
/// Extension pointers to query.
/// @param[in] object OpenCL object to query.
/// @param[in] param_name Specific information to query for.
/// @param[in] param_value_size Size of memory area pointed to by param_value.
/// Can be 0 if param_value is nullptr.
/// @param[out] param_value Memory area to store the query result in.
/// @param[out] param_value_size_ret Points to memory area to store the
/// minimally required param_value size in. Can be nullptr.
/// @param[in] name_separator char to separate aggregated param_value values
/// from different extensions.
/// @param[in] get_info_fn Function pointer, functor, or lambda which is called
/// for every extension.
///
/// @return Returns CL_SUCCESS if at least one extension accepts the param_name
/// query and the supplied argument values. CL_INVALID_VALUE if no extension
/// accepts the param_name query. Other OpenCL error return code if an extension
/// accepts param_name but the supplied argument values are wrong.
template <typename T, typename N, typename F>
cl_int GetObjectExtensionInfoAggregatedCString(
    const size_t num_extensions, const extension::extension* const* extensions,
    T object, N param_name, const size_t param_value_size, void* param_value,
    size_t* param_value_size_ret, const char name_separator, F get_info_fn) {
  // The caller already checked for correctness of the object.
  cl_int aggregated_retcode = CL_INVALID_VALUE;
  size_t aggregated_value_size_ret = 0;

  // First pass over extensions: aggregate the required return size.
  for (size_t ext_idx = 0; ext_idx < num_extensions; ++ext_idx) {
    // The last info query counts the terminating zero in its value_size_ret
    // while all previous terminating zeros are translated into spaces to
    // fulfill how OpenCL info queries report lists of names in c-strings.
    //
    // See The OpenCL Specification, Version 1.2,
    // Last Revision Date: 11/14/12,
    // Section 4.1 Querying Platform Info, page 35.
    size_t value_size_ret = 0;
    const cl_int retcode = get_info_fn(extensions[ext_idx], object, param_name,
                                       0, nullptr, &value_size_ret);
    if (CL_SUCCESS != retcode) {
      // This extension does not support the info query, skip it to find
      // extensions that do.
      continue;
    }

    // At least one extension supports the query info.
    aggregated_retcode = CL_SUCCESS;

    aggregated_value_size_ret += value_size_ret;
    OCL_ASSERT(
        value_size_ret <= aggregated_value_size_ret,
        "Overflow of variable for storing platform extension names size.");
  }

  // If no extension handles the param_name for object, then return with an
  // error code.
  if (CL_SUCCESS != aggregated_retcode) {
    return aggregated_retcode;
  }

  OCL_CHECK(
      nullptr != param_value && param_value_size < aggregated_value_size_ret,
      return CL_INVALID_VALUE);

  // Second pass: query the wanted info and store it in the arguments.
  if (nullptr != param_value) {
    char* value_cursor = static_cast<char*>(param_value);
    size_t value_size_remaining = param_value_size;

    for (size_t ext_idx = 0; ext_idx < num_extensions; ++ext_idx) {
      cl_int retcode = get_info_fn(extensions[ext_idx], object, param_name, 0,
                                   nullptr, nullptr);
      if (CL_SUCCESS != retcode) {
        // This extension does not support the info query, keep searching.
        continue;
      }

      size_t value_size_ret = 0;
      retcode =
          get_info_fn(extensions[ext_idx], object, param_name,
                      value_size_remaining, value_cursor, &value_size_ret);
      OCL_ASSERT(CL_SUCCESS == retcode,
                 "Second pass through extension information should not fail.");
      OCL_ASSERT(
          value_size_ret <= value_size_remaining,
          "Sizes must not add up differently between first and second pass.");

      value_cursor += value_size_ret;
      value_size_remaining -= value_size_ret;

      // Replace terminating zero with name list "concatenating" whitespace.
      //
      // See The OpenCL Specification, Version 1.2,
      // Last Revision Date: 11/14/12,
      // Section 4.1 Querying Platform Info, page 35.
      if (0 != value_size_ret) {
        *(value_cursor - 1) = name_separator;
      }
    }

    // Re-establish last terminating zero.
    if (0 != aggregated_value_size_ret) {
      *(value_cursor - 1) = '\0';
    }
  }

  OCL_SET_IF_NOT_NULL(param_value_size_ret, aggregated_value_size_ret);

  return CL_SUCCESS;
}

template <typename T, typename N, typename F>
cl_int GetObjectExtensionInfoAggregatedArray(
    const size_t num_extensions, const extension::extension* const* extensions,
    T object, N param_name, const size_t param_value_size, void* param_value,
    size_t* param_value_size_ret, F get_info_fn) {
  cl_int aggregated_retcode = CL_INVALID_VALUE;
  size_t aggregated_value_size_ret = 0;
  for (size_t ext_idx = 0; ext_idx < num_extensions; ++ext_idx) {
    size_t value_size_ret = 0;
    const cl_int retcode = get_info_fn(extensions[ext_idx], object, param_name,
                                       0, nullptr, &value_size_ret);
    if (CL_SUCCESS != retcode) {
      // This extension does not support the info query, skip it to find
      // extensions that do.
      continue;
    }
    // At least one extension supports the query info.
    aggregated_retcode = CL_SUCCESS;

    aggregated_value_size_ret += value_size_ret;
    OCL_ASSERT(
        value_size_ret <= aggregated_value_size_ret,
        "Overflow of variable for storing platform extension names size.");
  }

  // If no extension handles the param_name for object, then return with an
  // error code.
  if (CL_SUCCESS != aggregated_retcode) {
    return aggregated_retcode;
  }
  OCL_CHECK(
      nullptr != param_value && param_value_size < aggregated_value_size_ret,
      return CL_INVALID_VALUE);

  // Second pass: query the wanted info and store it in the arguments.
  if (nullptr != param_value) {
    char* value_cursor = static_cast<char*>(param_value);
    size_t value_size_remaining = param_value_size;

    for (size_t ext_idx = 0; ext_idx < num_extensions; ++ext_idx) {
      cl_int retcode = get_info_fn(extensions[ext_idx], object, param_name, 0,
                                   nullptr, nullptr);
      if (CL_SUCCESS != retcode) {
        // This extension does not support the info query, keep searching.
        continue;
      }

      size_t value_size_ret = 0;
      retcode =
          get_info_fn(extensions[ext_idx], object, param_name,
                      value_size_remaining, value_cursor, &value_size_ret);
      OCL_ASSERT(CL_SUCCESS == retcode,
                 "Second pass through extension information should not fail.");
      OCL_ASSERT(
          value_size_ret <= value_size_remaining,
          "Sizes must not add up differently between first and second pass.");

      value_cursor += value_size_ret;
      value_size_remaining -= value_size_ret;
    }
  }

  OCL_SET_IF_NOT_NULL(param_value_size_ret, aggregated_value_size_ret);

  return CL_SUCCESS;
}
}  // namespace

extension::extension::extension(const char* name, usage_category usage
#if defined(CL_VERSION_3_0)
                                ,
                                cl_version_khr version
#endif
                                )
    : name(name),
      usage(usage)
#if defined(CL_VERSION_3_0)
      ,
      version(version)
#endif
{
  OCL_ASSERT(nullptr != name || usage_category::DISABLED == usage,
             "Name required if usage indicates it.");
}

extension::extension::~extension() {}

cl_int extension::extension::GetPlatformInfo(
    cl_platform_id platform, cl_platform_info param_name,
    size_t param_value_size, void* param_value,
    size_t* param_value_size_ret) const {
  OCL_UNUSED(platform);  // Already checked by clGetPlatformInfo.
  if (usage_category::PLATFORM == usage) {
    switch (param_name) {
      default: { return CL_INVALID_VALUE; }
      case CL_PLATFORM_EXTENSIONS: {
        const std::size_t size = name.size() + 1;  // +1 for zero terminator.
        OCL_CHECK(nullptr != param_value && param_value_size < size,
                  return CL_INVALID_VALUE);

        if (nullptr != param_value) {
          std::memcpy(param_value, name.data(), size);
        }

        OCL_SET_IF_NOT_NULL(param_value_size_ret, size);

        return CL_SUCCESS;
      }
#if defined(CL_VERSION_3_0)
      case CL_PLATFORM_EXTENSIONS_WITH_VERSION: {
        size_t platform_extensions_size{};
        GetPlatformInfo(platform, CL_PLATFORM_EXTENSIONS, 0, nullptr,
                        &platform_extensions_size);
        std::string platform_extensions(platform_extensions_size, '\0');
        GetPlatformInfo(platform, CL_PLATFORM_EXTENSIONS,
                        platform_extensions.size(), platform_extensions.data(),
                        nullptr);
        auto split_extensions = cargo::split(platform_extensions, " ");
        auto size_in_bytes =
            split_extensions.size() * sizeof(cl_name_version_khr);
        OCL_CHECK(nullptr != param_value && (param_value_size < size_in_bytes),
                  return CL_INVALID_VALUE);
        cargo::small_vector<cl_name_version_khr, CA_CL_EXTENSION_COUNT>
            name_version_pairs{};
        if (nullptr != param_value) {
          for (const auto& extension : split_extensions) {
            cl_name_version_khr name_version{};
            name_version.version = version;
            std::memcpy(name_version.name, extension.data(), extension.size());
            name_version.name[extension.size()] = '\0';
            OCL_UNUSED(name_version_pairs.push_back(name_version));
          }
          std::memcpy(param_value, name_version_pairs.data(), size_in_bytes);
        }
        OCL_SET_IF_NOT_NULL(param_value_size_ret, size_in_bytes);
        return CL_SUCCESS;
      }
#endif
    }
  }

  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetDeviceInfo(cl_device_id device,
                                           cl_device_info param_name,
                                           size_t param_value_size,
                                           void* param_value,
                                           size_t* param_value_size_ret) const {
  OCL_UNUSED(device);  // Already checked by clGetDeviceInfo.
  if (usage_category::DEVICE == usage || usage_category::PLATFORM == usage) {
    // If this is a compiler extension and no compiler is available, then disable it.
    if (!device->compiler_available) {
      auto compiler_extensions = getCompilerExtensions();
      if (std::find(compiler_extensions.begin(), compiler_extensions.end(), this) != compiler_extensions.end()) {
        return CL_INVALID_DEVICE;
      }
    }
    switch (param_name) {
      default: { return CL_INVALID_VALUE; }
      case CL_DEVICE_EXTENSIONS: {
        const std::size_t size = name.size() + 1;
        OCL_CHECK(nullptr != param_value && param_value_size < size,
                  return CL_INVALID_VALUE);

        if (nullptr != param_value) {
          std::memcpy(param_value, name.data(), size);
        }

        OCL_SET_IF_NOT_NULL(param_value_size_ret, size);

        return CL_SUCCESS;
      }
#if defined(CL_VERSION_3_0)
      case CL_DEVICE_EXTENSIONS_WITH_VERSION: {
        size_t device_extensions_size{};
        GetDeviceInfo(device, CL_DEVICE_EXTENSIONS, 0, nullptr,
                      &device_extensions_size);
        std::string device_extensions(device_extensions_size, '\0');
        GetDeviceInfo(device, CL_DEVICE_EXTENSIONS, device_extensions.size(),
                      device_extensions.data(), nullptr);
        auto split_extensions = cargo::split(device_extensions, " ");
        auto size_in_bytes =
            split_extensions.size() * sizeof(cl_name_version_khr);
        OCL_CHECK(nullptr != param_value && (param_value_size < size_in_bytes),
                  return CL_INVALID_VALUE);
        if (nullptr != param_value) {
          cargo::small_vector<cl_name_version_khr, CA_CL_EXTENSION_COUNT>
              name_version_pairs{};
          for (const auto& extension : split_extensions) {
            cl_name_version_khr name_version{};
            name_version.version = version;
            std::memcpy(name_version.name, extension.data(), extension.size());
            name_version.name[extension.size()] = '\0';
            OCL_UNUSED(name_version_pairs.push_back(name_version));
          }
          std::memcpy(param_value, name_version_pairs.data(), size_in_bytes);
        }
        OCL_SET_IF_NOT_NULL(param_value_size_ret, size_in_bytes);
        return CL_SUCCESS;
      }
#endif
    }
  }

  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetContextInfo(cl_context, cl_context_info, size_t,
                                            void*, size_t*) const {
  return CL_INVALID_VALUE;
}

cargo::optional<cl_int> extension::extension::ApplyPropertyToCommandQueue(
    cl_command_queue, cl_queue_properties_khr, cl_queue_properties_khr) const {
  return cargo::nullopt;
}

cl_int extension::extension::GetCommandQueueInfo(cl_command_queue,
                                                 cl_command_queue_info, size_t,
                                                 void*, size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetImageInfo(cl_mem, cl_image_info, size_t, void*,
                                          size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetMemObjectInfo(cl_mem, cl_mem_info, size_t,
                                              void*, size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetSamplerInfo(cl_sampler, cl_sampler_info, size_t,
                                            void*, size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetProgramInfo(cl_program, cl_program_info, size_t,
                                            void*, size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetProgramBuildInfo(cl_program, cl_device_id,
                                                 cl_program_build_info, size_t,
                                                 void*, size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetKernelInfo(cl_kernel, cl_kernel_info, size_t,
                                           void*, size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetKernelWorkGroupInfo(cl_kernel, cl_device_id,
                                                    cl_kernel_work_group_info,
                                                    size_t, void*,
                                                    size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::SetKernelArg(cl_kernel, cl_uint, size_t,
                                          const void*) const {
  return CL_INVALID_KERNEL;
}

cl_int extension::extension::GetKernelArgInfo(cl_kernel, cl_uint,
                                              cl_kernel_arg_info, size_t, void*,
                                              size_t*) const {
  return CL_INVALID_VALUE;
}

#if defined(CL_VERSION_3_0)
cl_int extension::extension::GetKernelSubGroupInfo(cl_kernel, cl_device_id,
                                                   cl_kernel_sub_group_info,
                                                   size_t, const void *, size_t,
                                                   void *, size_t *) const {
  return CL_INVALID_VALUE;
}
#endif

#if (defined(CL_VERSION_3_0) || \
     defined(OCL_EXTENSION_cl_codeplay_kernel_exec_info))
cl_int extension::extension::SetKernelExecInfo(cl_kernel, cl_kernel_exec_info_codeplay,
                                               size_t, const void*) const {
  return CL_INVALID_KERNEL;
}
#endif

cl_int extension::extension::GetEventInfo(cl_event, cl_event_info, size_t,
                                          void*, size_t*) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetEventProfilingInfo(cl_event, cl_profiling_info,
                                                   size_t, void*,
                                                   size_t*) const {
  return CL_INVALID_VALUE;
}

void* extension::extension::GetExtensionFunctionAddressForPlatform(
    cl_platform_id, const char*) const {
  return nullptr;
}

cl_int extension::GetPlatformInfo(cl_platform_id platform,
                                  cl_platform_info param_name,
                                  size_t param_value_size, void* param_value,
                                  size_t* param_value_size_ret) {
  cl_int retcode = CL_INVALID_VALUE;

  auto query_fn = [](const extension* extension, cl_platform_id object,
                     cl_platform_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetPlatformInfo(object, param_name, param_value_size,
                                      param_value, param_value_size_ret);
  };

  // Extend with extension related param_names.
  switch (param_name) {
    case CL_PLATFORM_EXTENSIONS: {
      const char extension_name_separator = ' ';
      retcode = GetObjectExtensionInfoAggregatedCString(
          getExtensions().size(), getExtensions().data(), platform, param_name,
          param_value_size, param_value, param_value_size_ret,
          extension_name_separator, query_fn);
      break;
    }
#if defined(CL_VERSION_3_0)
    case CL_PLATFORM_EXTENSIONS_WITH_VERSION: {
      retcode = GetObjectExtensionInfoAggregatedArray(
          getExtensions().size(), getExtensions().data(), platform, param_name,
          param_value_size, param_value, param_value_size_ret, query_fn);
      }
      break;
#endif
    default: {
      // Assuming that yet unknown extension have a single value to query
      // and are not aggregated.
      retcode = GetObjectExtensionInfoSingleValue(
          getExtensions().size(), getExtensions().data(), platform, param_name,
          param_value_size, param_value, param_value_size_ret, query_fn);
      break;
    }
  }

  return retcode;
}

cl_int extension::GetDeviceInfo(cl_device_id device, cl_device_info param_name,
                                size_t param_value_size, void* param_value,
                                size_t* param_value_size_ret) {
  cl_int retcode = CL_INVALID_VALUE;

  auto query_fn = [](const extension* extension, cl_device_id object,
                     cl_device_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetDeviceInfo(object, param_name, param_value_size,
                                    param_value, param_value_size_ret);
  };

  // Extend with extension related param_names.
  switch (param_name) {
    case CL_DEVICE_EXTENSIONS: {
      const char extension_name_separator = ' ';
      retcode = GetObjectExtensionInfoAggregatedCString(
          getExtensions().size(), getExtensions().data(), device, param_name,
          param_value_size, param_value, param_value_size_ret,
          extension_name_separator, query_fn);
      break;
    }
#if defined(CL_VERSION_3_0)
    case CL_DEVICE_EXTENSIONS_WITH_VERSION: {
      retcode = GetObjectExtensionInfoAggregatedArray(
          getExtensions().size(), getExtensions().data(), device, param_name,
          param_value_size, param_value, param_value_size_ret, query_fn);
      }
      break;
#endif
    default: {
      // Assuming that yet unknown extension have a single value to query
      // and are not aggregated.
      retcode = GetObjectExtensionInfoSingleValue(
          getExtensions().size(), getExtensions().data(), device, param_name,
          param_value_size, param_value, param_value_size_ret, query_fn);
      break;
    }
  }

  return retcode;
}

cl_int extension::GetContextInfo(cl_context context, cl_context_info param_name,
                                 size_t param_value_size, void* param_value,
                                 size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_context object,
                     cl_context_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetContextInfo(object, param_name, param_value_size,
                                     param_value, param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), context, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

cl_int extension::ApplyPropertyToCommandQueue(cl_command_queue command_queue,
                                              cl_queue_properties_khr property,
                                              cl_queue_properties_khr value) {
  for (auto extension : getExtensions()) {
    if (auto result = extension->ApplyPropertyToCommandQueue(command_queue,
                                                             property, value)) {
      return *result;
    }
  }
  return CL_INVALID_VALUE;
}

cl_int extension::GetCommandQueueInfo(cl_command_queue command_queue,
                                      cl_command_queue_info param_name,
                                      size_t param_value_size,
                                      void* param_value,
                                      size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_command_queue object,
                     cl_command_queue_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetCommandQueueInfo(object, param_name, param_value_size,
                                          param_value, param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), command_queue, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

cl_int extension::GetImageInfo(cl_mem image, cl_image_info param_name,
                               size_t param_value_size, void* param_value,
                               size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_mem object,
                     cl_image_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetImageInfo(object, param_name, param_value_size,
                                   param_value, param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), image, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

cl_int extension::GetMemObjectInfo(cl_mem memobj, cl_mem_info param_name,
                                   size_t param_value_size, void* param_value,
                                   size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_mem object,
                     cl_mem_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetMemObjectInfo(object, param_name, param_value_size,
                                       param_value, param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), memobj, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

cl_int extension::GetSamplerInfo(cl_sampler sampler, cl_sampler_info param_name,
                                 size_t param_value_size, void* param_value,
                                 size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_sampler object,
                     cl_sampler_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetSamplerInfo(object, param_name, param_value_size,
                                     param_value, param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), sampler, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

cl_int extension::GetProgramInfo(cl_program program, cl_program_info param_name,
                                 size_t param_value_size, void* param_value,
                                 size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_program object,
                     cl_program_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetProgramInfo(object, param_name, param_value_size,
                                     param_value, param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), program, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

cl_int extension::GetProgramBuildInfo(cl_program program, cl_device_id device,
                                      cl_program_build_info param_name,
                                      size_t param_value_size,
                                      void* param_value,
                                      size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_program object,
                     cl_device_id detail, cl_program_build_info param_name,
                     size_t param_value_size, void* param_value,
                     size_t* param_value_size_ret) {
    return extension->GetProgramBuildInfo(object, detail, param_name,
                                          param_value_size, param_value,
                                          param_value_size_ret);
  };

  return GetObjectDetailExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), program, device,
      param_name, param_value_size, param_value, param_value_size_ret,
      query_fn);
}

cl_int extension::GetKernelInfo(cl_kernel kernel, cl_kernel_info param_name,
                                size_t param_value_size, void* param_value,
                                size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_kernel object,
                     cl_kernel_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetKernelInfo(object, param_name, param_value_size,
                                    param_value, param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), kernel, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

cl_int extension::GetKernelWorkGroupInfo(cl_kernel kernel, cl_device_id device,
                                         cl_kernel_work_group_info param_name,
                                         size_t param_value_size,
                                         void* param_value,
                                         size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_kernel object,
                     cl_device_id detail, cl_kernel_work_group_info param_name,
                     size_t param_value_size, void* param_value,
                     size_t* param_value_size_ret) {
    return extension->GetKernelWorkGroupInfo(object, detail, param_name,
                                             param_value_size, param_value,
                                             param_value_size_ret);
  };

  return GetObjectDetailExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), kernel, device,
      param_name, param_value_size, param_value, param_value_size_ret,
      query_fn);
}

cl_int extension::SetKernelArg(cl_kernel kernel, cl_uint arg_index,
                               size_t arg_size, const void* arg_value) {
  for (auto extension : getExtensions()) {
    auto error =
        extension->SetKernelArg(kernel, arg_index, arg_size, arg_value);
    if (error != CL_INVALID_KERNEL) {
      return error;
    }
  }
  return CL_INVALID_KERNEL;
}

cl_int extension::GetKernelArgInfo(cl_kernel kernel, cl_uint arg_indx,
                                   cl_kernel_arg_info param_name,
                                   size_t param_value_size, void* param_value,
                                   size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_kernel object,
                     cl_uint detail, cl_kernel_arg_info param_name,
                     size_t param_value_size, void* param_value,
                     size_t* param_value_size_ret) {
    return extension->GetKernelArgInfo(object, detail, param_name,
                                       param_value_size, param_value,
                                       param_value_size_ret);
  };

  return GetObjectDetailExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), kernel, arg_indx,
      param_name, param_value_size, param_value, param_value_size_ret,
      query_fn);
}

#if defined(CL_VERSION_3_0)
cl_int extension::GetKernelSubGroupInfo(
    cl_kernel kernel, cl_device_id device, cl_kernel_sub_group_info param_name,
    size_t input_value_size, const void *input_value, size_t param_value_size,
    void *param_value, size_t *param_value_size_ret) {
  auto query_fn = [](const extension *extension, cl_kernel object,
                     cl_device_id detail, cl_kernel_sub_group_info param_name,
                     size_t input_value_size, const void *input_value,
                     size_t param_value_size, void *param_value,
                     size_t *param_value_size_ret) {
    return extension->GetKernelSubGroupInfo(
        object, detail, param_name, input_value_size, input_value,
        param_value_size, param_value, param_value_size_ret);
  };

  return GetObjectDetailExtensionInfoSingleInputValue(
      getExtensions().size(), getExtensions().data(), kernel, device,
      param_name, input_value_size, input_value, param_value_size, param_value,
      param_value_size_ret, query_fn);
}
#endif

#if (defined(CL_VERSION_3_0) || \
     defined(OCL_EXTENSION_cl_codeplay_kernel_exec_info))
cl_int extension::SetKernelExecInfo(cl_kernel kernel,
                                    cl_kernel_exec_info_codeplay param_name,
                                    size_t param_value_size,
                                    const void* param_value) {
  for (auto extension : getExtensions()) {
    auto error =
        extension->SetKernelExecInfo(kernel, param_name, param_value_size,
                                     param_value);
    if (error != CL_INVALID_KERNEL) {
      return error;
    }
  }
  return CL_INVALID_KERNEL;
}
#endif

cl_int extension::GetEventInfo(cl_event event, cl_event_info param_name,
                               size_t param_value_size, void* param_value,
                               size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_event object,
                     cl_event_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetEventInfo(object, param_name, param_value_size,
                                   param_value, param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), event, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

cl_int extension::GetEventProfilingInfo(cl_event event,
                                        cl_profiling_info param_name,
                                        size_t param_value_size,
                                        void* param_value,
                                        size_t* param_value_size_ret) {
  auto query_fn = [](const extension* extension, cl_event object,
                     cl_profiling_info param_name, size_t param_value_size,
                     void* param_value, size_t* param_value_size_ret) {
    return extension->GetEventProfilingInfo(object, param_name,
                                            param_value_size, param_value,
                                            param_value_size_ret);
  };

  return GetObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), event, param_name,
      param_value_size, param_value, param_value_size_ret, query_fn);
}

void* extension::GetExtensionFunctionAddressForPlatform(cl_platform_id platform,
                                                        const char* func_name) {
  return ::GetExtensionFunctionAddressForPlatform(
      getExtensions().size(), getExtensions().data(), platform, func_name);
}

[[nodiscard]] cl_int extension::GetRuntimeExtensionsForDevice(
    cl_device_id device, cargo::string_view& extensions_ret) {
  static std::string extensions{};
  static std::once_flag initialized_flag{};
  static cl_int retcode = CL_SUCCESS;

  std::call_once(initialized_flag, [&]() {
    auto query_fn = [](const extension* extension, cl_device_id object,
                       cl_device_info param_name, size_t param_value_size,
                       void* param_value, size_t* param_value_size_ret) {
      return extension->GetDeviceInfo(object, param_name, param_value_size,
                                      param_value, param_value_size_ret);
    };

    size_t ext_string_length = 0;
    retcode = GetObjectExtensionInfoAggregatedCString(
        getRuntimeExtensions().size(), getRuntimeExtensions().data(), device,
        CL_DEVICE_EXTENSIONS, 0, nullptr, &ext_string_length, ' ', query_fn);

    // CL_INVALID_VALUE indicates that the device supports no extensions
    if (CL_INVALID_VALUE == retcode) {
      retcode = CL_SUCCESS;
      return;
    }
    if (CL_SUCCESS != retcode) {
      return;
    }

    extensions = std::string(ext_string_length, '\0');
    retcode = GetObjectExtensionInfoAggregatedCString(
        getRuntimeExtensions().size(), getRuntimeExtensions().data(), device,
        CL_DEVICE_EXTENSIONS, ext_string_length, extensions.data(), nullptr,
        ' ', query_fn);
    if (CL_SUCCESS != retcode) {
      return;
    }
  });

  if (CL_SUCCESS == retcode) {
    extensions_ret = cargo::string_view(extensions.data(), extensions.size());
  }

  return retcode;
}

[[nodiscard]] cl_int extension::GetCompilerExtensionsForDevice(
    cl_device_id device, cargo::string_view& extensions_ret) {
  static std::string extensions{};
  static std::once_flag initialized_flag{};
  static cl_int retcode = CL_SUCCESS;

  std::call_once(initialized_flag, [&]() {
    auto query_fn = [](const extension* extension, cl_device_id object,
                       cl_device_info param_name, size_t param_value_size,
                       void* param_value, size_t* param_value_size_ret) {
      return extension->GetDeviceInfo(object, param_name, param_value_size,
                                      param_value, param_value_size_ret);
    };

    size_t ext_string_length = 0;
    retcode = GetObjectExtensionInfoAggregatedCString(
        getCompilerExtensions().size(), getCompilerExtensions().data(), device,
        CL_DEVICE_EXTENSIONS, 0, nullptr, &ext_string_length, ' ', query_fn);

    // CL_INVALID_VALUE indicates that the device supports no etensions
    if (CL_INVALID_VALUE == retcode) {
      retcode = CL_SUCCESS;
      return;
    }
    if (CL_SUCCESS != retcode) {
      return;
    }

    extensions = std::string(ext_string_length, '\0');
    retcode = GetObjectExtensionInfoAggregatedCString(
        getCompilerExtensions().size(), getCompilerExtensions().data(), device,
        CL_DEVICE_EXTENSIONS, ext_string_length, extensions.data(), nullptr,
        ' ', query_fn);
    if (CL_SUCCESS != retcode) {
      return;
    }
  });

  if (CL_SUCCESS == retcode) {
    extensions_ret = cargo::string_view(extensions.data(), extensions.size());
  }

  return retcode;
}
