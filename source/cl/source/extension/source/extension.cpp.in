// Copyright (C) Codeplay Software Limited
//
// Licensed under the Apache License, Version 2.0 (the "License") with LLVM
// Exceptions; you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://github.com/uxlfoundation/oneapi-construction-kit/blob/main/LICENSE.txt
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.
//
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#include <cargo/array_view.h>
#include <cargo/small_vector.h>
#include <cargo/string_algorithm.h>

@generate_includes@

#include <cl/device.h>

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <mutex>

namespace {
template <typename T>
static T Extension;
cargo::array_view<const extension::extension *const> getExtensions() {
  static cargo::small_vector<const extension::extension *,
                             CA_CL_EXTENSION_COUNT>
      Extensions;
  static std::once_flag InitializedFlag;

  std::call_once(InitializedFlag, []() {
    cargo::result Error;
    OCL_UNUSED(Error);
@generate_alloc_error@
  });

  return Extensions;
}

cargo::array_view<const extension::extension *const> getRuntimeExtensions() {
  static cargo::array_view<const extension::extension *const>
      RuntimeExtensions{getExtensions().data(), CA_CL_RUNTIME_EXTENSION_COUNT};
  return RuntimeExtensions;
}

cargo::array_view<const extension::extension *const> getCompilerExtensions() {
  static cargo::array_view<const extension::extension *const>
      CompilerExtensions{
          getExtensions().data() + CA_CL_RUNTIME_EXTENSION_COUNT,
          CA_CL_COMPILER_EXTENSION_COUNT};
  return CompilerExtensions;
}

void *getExtensionFunctionAddressForPlatform(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    cl_platform_id Platform, const char *FuncName) {
  OCL_ASSERT(
      nullptr != Platform,
      "Invalid platform. Expecting caller to map nullptr to a valid platform.");

  if (nullptr == FuncName) {
    return nullptr;
  }

  void *FunctionAddress = nullptr;
  for (size_t TableIdx = 0; TableIdx < NumExtensions; ++TableIdx) {
    FunctionAddress =
        Extensions[TableIdx]->GetExtensionFunctionAddressForPlatform(
            Platform, FuncName);
    if (nullptr != FunctionAddress) {
      // Found a function address for func_name, stop the loop.
      // Check that there aren't multiple extensions using the same func_name
      // because then extension ordering determines discovery. Extension
      // function names should be unique.
      OCL_ASSERT(
          nullptr == getExtensionFunctionAddressForPlatform(
                         NumExtensions - TableIdx - 1,
                         Extensions + TableIdx + 1, Platform, FuncName),
          "Each extension function must belong to exactly one extension info.");
      break;
    }
  }

  return FunctionAddress;
}

template <typename T, typename N, typename F>
inline cl_int getObjectExtensionInfoSingleValue(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, N ParamName, const size_t ParamValueSize, void *ParamValue,
    size_t *ParamValueSizeRet, F GetInfoFn);

template <typename T, typename D, typename N, typename F>
inline cl_int getObjectDetailExtensionInfoSingleValue(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, D Detail, N ParamName, const size_t ParamValueSize,
    void *ParamValue, size_t *ParamValueSizeRet, F GetInfoFn);

template <typename T, typename D, typename N, typename F>
inline cl_int getObjectDetailExtensionInfoSingleInputValue(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, D Detail, N ParamName, const size_t InputValueSize,
    const void *InputValue, const size_t ParamValueSize, void *ParamValue,
    size_t *ParamValueSizeRet, F GetInfoFn);

template <typename T, typename N, typename F>
inline cl_int getObjectExtensionInfoAggregatedCString(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, N ParamName, const size_t ParamValueSize, void *ParamValue,
    size_t *ParamValueSizeRet, const char NameSeparator, F GetInfoFn);

/// @brief Query all passed in extensions via the get_info_fn functor/lambda
/// until one accepts the query.
///
/// If no extension in extensions accepts the param_name query, then
/// CL_INVALID_VALUE is returned.
///
/// @see OpenCL clGet...Info calls for more in-detail explanations of
/// param_name, param_value_size, param_value, param_value_size_ret, and
/// possible return codes.
///
/// @tparam T Type of the OpenCL object, e.g., cl_platform.
/// @tparam N Type of the param_name to query for.
/// @tparam F Type of the function/functor/lambda to use for the query.
/// @param[in] num_extensions Number of extensions to query.
/// @param[in] extensions Contiguous memory area containing num_extensions
/// Extension pointers to query.
/// @param[in] object OpenCL object to query.
/// @param[in] param_name Specific information to query for.
/// @param[in] param_value_size Size of memory area pointed to by param_value.
/// Can be 0 if param_value is nullptr.
/// @param[out] param_value Memory area to store the query result in.
/// @param[out] param_value_size_ret Points to memory area to store the
/// minimally required param_value size in. Can be nullptr.
/// @param[in] get_info_fn Function pointer, functor, or lambda which is called
/// for every extension.
///
/// @return Returns CL_SUCCESS if an extension accepts the param_name query and
/// the supplied argument values. CL_INVALID_VALUE if no extension accepts the
/// param_name query. Other OpenCL error return code if an extension accepts
/// param_name but the supplied argument values are wrong.
template <typename T, typename N, typename F>
cl_int getObjectExtensionInfoSingleValue(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, N ParamName, const size_t ParamValueSize, void *ParamValue,
    size_t *ParamValueSizeRet, F GetInfoFn) {
  cl_int Retcode = CL_INVALID_VALUE;
  size_t ExtIdx = 0;
  for (ExtIdx = 0; ExtIdx < NumExtensions; ++ExtIdx) {
    const cl_int SupportedRetcode = GetInfoFn(
        Extensions[ExtIdx], Object, ParamName, 0, nullptr, nullptr);
    if (CL_SUCCESS != SupportedRetcode) {
      // This extension does not support the info query, keep searching.
      continue;
    }

    // Do query.
    Retcode = GetInfoFn(Extensions[ExtIdx], Object, ParamName,
                          ParamValueSize, ParamValue, ParamValueSizeRet);

    // More than one extension shouldn't support the same info query,
    // otherwise results are order dependent which is confusing.
    OCL_ASSERT(
        CL_SUCCESS != Retcode ||
            CL_SUCCESS != getObjectExtensionInfoSingleValue(
                              NumExtensions - ExtIdx - 1,
                              Extensions + ExtIdx + 1, Object, ParamName, 0,
                              nullptr, nullptr, GetInfoFn),
        "More than one extension should not support the same info query, "
        "otherwise results are order dependent which is confusing.");

    // One extension supporting the info query or one error is enough to stop
    // the search.
    break;
  }

  return Retcode;
}

/// @brief Query all passed in extensions via the get_info_fn functor/lambda
/// until one accepts the query.
///
/// Query for details from OpenCL objects, e.g., applicable to the following
/// info queries:
/// * clGetProgramBuildInfo
/// * clGetKernelWorkGroupInfo,
/// * clGetKernelArgInfo.
///
/// If no extension in extensions accepts the param_name query, then
/// CL_INVALID_VALUE is returned.
///
/// @see OpenCL clGet...Info calls listed above for more in-detail explanations
/// of param_name, param_value_size, param_value, param_value_size_ret, and
/// possible return codes.
///
/// @tparam T Type of the OpenCL object, e.g., cl_platform.
/// @tparam D Type of the detail info to query for.
/// @tparam N Type of the param_name to query for.
/// @tparam F Type of the function/functor/lambda to use for the
///                  query.
/// @param[in] num_extensions Number of extensions to query.
/// @param[in] extensions Contiguous memory area containing num_extensions
/// Extension pointers to query.
/// @param[in] object OpenCL object to query.
/// @param[in] detail Detail info to query for.
/// @param[in] param_name Specific information to query for.
/// @param[in] param_value_size Size of memory area pointed to by param_value.
/// Can be 0 if param_value is nullptr.
/// @param[out] param_value Memory area to store the query result in.
/// @param[out] param_value_size_ret Points to memory area to store the
/// minimally required param_value size in. Can be nullptr.
/// @param[in] get_info_fn Function pointer, functor, or lambda which is called
/// for every extension.
///
/// @return Returns CL_SUCCESS if an extension accepts the param_name query and
/// the supplied argument values. CL_INVALID_VALUE if no extension accepts the
/// param_name query. Other OpenCL error return code if an extension accepts
/// param_name but the supplied argument values are wrong.
template <typename T, typename D, typename N, typename F>
cl_int getObjectDetailExtensionInfoSingleValue(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, D Detail, N ParamName, const size_t ParamValueSize,
    void *ParamValue, size_t *ParamValueSizeRet, F GetInfoFn) {
  cl_int Retcode = CL_INVALID_VALUE;
  size_t ExtIdx = 0;
  for (ExtIdx = 0; ExtIdx < NumExtensions; ++ExtIdx) {
    const cl_int SupportedRetcode = GetInfoFn(
        Extensions[ExtIdx], Object, Detail, ParamName, 0, nullptr, nullptr);
    if (CL_SUCCESS != SupportedRetcode) {
      // This extension does not support the info query, keep searching.
      continue;
    }

    // Do query.
    Retcode = GetInfoFn(Extensions[ExtIdx], Object, Detail, ParamName,
                          ParamValueSize, ParamValue, ParamValueSizeRet);

    // More than one extension shouldn't support the same info query,
    // otherwise results are order dependent which is confusing.
    OCL_ASSERT(
        CL_SUCCESS != Retcode ||
            CL_SUCCESS != getObjectDetailExtensionInfoSingleValue(
                              NumExtensions - ExtIdx - 1,
                              Extensions + ExtIdx + 1, Object, Detail,
                              ParamName, 0, nullptr, nullptr, GetInfoFn),
        "More than one extension should not support the same info query, "
        "otherwise results are order dependent which is confusing.");

    // One extension supporting the info query or one error is enough to stop
    // the search.
    break;
  }

  return Retcode;
}

/// @brief Query all passed in extensions via the get_info_fn functor/lambda
/// until one accepts the query.
///
/// Query for details from OpenCL objects, e.g., applicable to the following
/// info queries:
/// * clGetKernelSubGroupInfo,
///
/// If no extension in extensions accepts the param_name query, then
/// CL_INVALID_VALUE is returned.
///
/// @see OpenCL clGet...Info calls listed above for more in-detail explanations
/// of param_name, param_value_size, param_value, param_value_size_ret, and
/// possible return codes.
///
/// @tparam T Type of the OpenCL object, e.g., cl_platform.
/// @tparam D Type of the detail info to query for.
/// @tparam N Type of the param_name to query for.
/// @tparam F Type of the function/functor/lambda to use for the
///                  query.
/// @param[in] num_extensions Number of extensions to query.
/// @param[in] extensions Contiguous memory area containing num_extensions
/// Extension pointers to query.
/// @param[in] object OpenCL object to query.
/// @param[in] detail Detail info to query for.
/// @param[in] param_name Specific information to query for.
/// @param[in] param_value_size Size of memory area pointed to by param_value.
/// Can be 0 if param_value is nullptr.
/// @param[out] param_value Memory area to store the query result in.
/// @param[out] param_value_size_ret Points to memory area to store the
/// minimally required param_value size in. Can be nullptr.
/// @param[in] get_info_fn Function pointer, functor, or lambda which is called
/// for every extension.
///
/// @return Returns CL_SUCCESS if an extension accepts the param_name query and
/// the supplied argument values. CL_INVALID_VALUE if no extension accepts the
/// param_name query. Other OpenCL error return code if an extension accepts
/// param_name but the supplied argument values are wrong.
template <typename T, typename D, typename N, typename F>
cl_int getObjectDetailExtensionInfoSingleInputValue(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, D Detail, N ParamName, const size_t InputValueSize,
    const void *InputValue, const size_t ParamValueSize, void *ParamValue,
    size_t *ParamValueSizeRet, F GetInfoFn) {
  cl_int Retcode = CL_INVALID_VALUE;
  size_t ExtIdx = 0;
  for (ExtIdx = 0; ExtIdx < NumExtensions; ++ExtIdx) {
    const cl_int SupportedRetcode =
        GetInfoFn(Extensions[ExtIdx], Object, Detail, ParamName, 0, nullptr,
                    0, nullptr, nullptr);
    if (CL_SUCCESS != SupportedRetcode) {
      // This extension does not support the info query, keep searching.
      continue;
    }

    // Do query.
    Retcode = GetInfoFn(Extensions[ExtIdx], Object, Detail, ParamName,
                          InputValueSize, InputValue, ParamValueSize,
                          ParamValue, ParamValueSizeRet);

    // More than one extension shouldn't support the same info query,
    // otherwise results are order dependent which is confusing.
    OCL_ASSERT(
        CL_SUCCESS != Retcode ||
            CL_SUCCESS != getObjectDetailExtensionInfoSingleInputValue(
                              NumExtensions - ExtIdx - 1,
                              Extensions + ExtIdx + 1, Object, Detail,
                              ParamName, 0, nullptr, 0, nullptr, nullptr,
                              GetInfoFn),
        "More than one extension should not support the same info query, "
        "otherwise results are order dependent which is confusing.");

    // One extension supporting the info query or one error is enough to stop
    // the search.
    break;
  }

  return Retcode;
}

/// @brief Query all passed in extensions via the get_info_fn functor/lambda and
/// aggregate the param_value c string into a single c string for all extensions
/// that accept param_name.
///
/// If no extension in extensions accepts the param_name query, then
/// CL_INVALID_VALUE is returned.
///
/// @see OpenCL clGetPlatformInfo for param_name CL_PLATFORM_EXTENSIONS or
/// clGetDeviceInfo calls for param_name CL_DEVICE_EXTENSIONS more in-detail
/// explanations of param_name, param_value_size, param_value,
/// param_value_size_ret, and possible return codes.
///
/// @tparam T Type of the OpenCL object, e.g., cl_platform.
/// @tparam N Type of the param_name to query for.
/// @tparam F Type of the function/functor/lambda to use for the query.
/// @param[in] num_extensions Number of extensions to query.
/// @param[in] extensions Contiguous memory area containing num_extensions
/// Extension pointers to query.
/// @param[in] object OpenCL object to query.
/// @param[in] param_name Specific information to query for.
/// @param[in] param_value_size Size of memory area pointed to by param_value.
/// Can be 0 if param_value is nullptr.
/// @param[out] param_value Memory area to store the query result in.
/// @param[out] param_value_size_ret Points to memory area to store the
/// minimally required param_value size in. Can be nullptr.
/// @param[in] name_separator char to separate aggregated param_value values
/// from different extensions.
/// @param[in] get_info_fn Function pointer, functor, or lambda which is called
/// for every extension.
///
/// @return Returns CL_SUCCESS if at least one extension accepts the param_name
/// query and the supplied argument values. CL_INVALID_VALUE if no extension
/// accepts the param_name query. Other OpenCL error return code if an extension
/// accepts param_name but the supplied argument values are wrong.
template <typename T, typename N, typename F>
cl_int getObjectExtensionInfoAggregatedCString(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, N ParamName, const size_t ParamValueSize, void *ParamValue,
    size_t *ParamValueSizeRet, const char NameSeparator, F GetInfoFn) {
  // The caller already checked for correctness of the object.
  cl_int AggregatedRetcode = CL_INVALID_VALUE;
  size_t AggregatedValueSizeRet = 0;

  // First pass over extensions: aggregate the required return size.
  for (size_t ExtIdx = 0; ExtIdx < NumExtensions; ++ExtIdx) {
    // The last info query counts the terminating zero in its value_size_ret
    // while all previous terminating zeros are translated into spaces to
    // fulfill how OpenCL info queries report lists of names in c-strings.
    //
    // See The OpenCL Specification, Version 1.2,
    // Last Revision Date: 11/14/12,
    // Section 4.1 Querying Platform Info, page 35.
    size_t ValueSizeRet = 0;
    const cl_int Retcode = GetInfoFn(Extensions[ExtIdx], Object, ParamName,
                                       0, nullptr, &ValueSizeRet);
    if (CL_SUCCESS != Retcode) {
      // This extension does not support the info query, skip it to find
      // extensions that do.
      continue;
    }

    // At least one extension supports the query info.
    AggregatedRetcode = CL_SUCCESS;

    AggregatedValueSizeRet += ValueSizeRet;
    OCL_ASSERT(
        ValueSizeRet <= AggregatedValueSizeRet,
        "Overflow of variable for storing platform extension names size.");
  }

  // If no extension handles the param_name for object, then return with an
  // error code.
  if (CL_SUCCESS != AggregatedRetcode) {
    return AggregatedRetcode;
  }

  OCL_CHECK(
      nullptr != ParamValue && ParamValueSize < AggregatedValueSizeRet,
      return CL_INVALID_VALUE);

  // Second pass: query the wanted info and store it in the arguments.
  if (nullptr != ParamValue) {
    char *ValueCursor = static_cast<char *>(ParamValue);
    size_t ValueSizeRemaining = ParamValueSize;

    for (size_t ExtIdx = 0; ExtIdx < NumExtensions; ++ExtIdx) {
      cl_int Retcode = GetInfoFn(Extensions[ExtIdx], Object, ParamName, 0,
                                   nullptr, nullptr);
      if (CL_SUCCESS != Retcode) {
        // This extension does not support the info query, keep searching.
        continue;
      }

      size_t ValueSizeRet = 0;
      Retcode =
          GetInfoFn(Extensions[ExtIdx], Object, ParamName,
                      ValueSizeRemaining, ValueCursor, &ValueSizeRet);
      OCL_ASSERT(CL_SUCCESS == Retcode,
                 "Second pass through extension information should not fail.");
      OCL_ASSERT(
          ValueSizeRet <= ValueSizeRemaining,
          "Sizes must not add up differently between first and second pass.");

      ValueCursor += ValueSizeRet;
      ValueSizeRemaining -= ValueSizeRet;

      // Replace terminating zero with name list "concatenating" whitespace.
      //
      // See The OpenCL Specification, Version 1.2,
      // Last Revision Date: 11/14/12,
      // Section 4.1 Querying Platform Info, page 35.
      if (0 != ValueSizeRet) {
        *(ValueCursor - 1) = NameSeparator;
      }
    }

    // Re-establish last terminating zero.
    if (0 != AggregatedValueSizeRet) {
      *(ValueCursor - 1) = '\0';
    }
  }

  OCL_SET_IF_NOT_NULL(ParamValueSizeRet, AggregatedValueSizeRet);

  return CL_SUCCESS;
}

template <typename T, typename N, typename F>
cl_int getObjectExtensionInfoAggregatedArray(
    const size_t NumExtensions, const extension::extension *const *Extensions,
    T Object, N ParamName, const size_t ParamValueSize, void *ParamValue,
    size_t *ParamValueSizeRet, F GetInfoFn) {
  cl_int AggregatedRetcode = CL_INVALID_VALUE;
  size_t AggregatedValueSizeRet = 0;
  for (size_t ExtIdx = 0; ExtIdx < NumExtensions; ++ExtIdx) {
    size_t ValueSizeRet = 0;
    const cl_int Retcode = GetInfoFn(Extensions[ExtIdx], Object, ParamName,
                                       0, nullptr, &ValueSizeRet);
    if (CL_SUCCESS != Retcode) {
      // This extension does not support the info query, skip it to find
      // extensions that do.
      continue;
    }
    // At least one extension supports the query info.
    AggregatedRetcode = CL_SUCCESS;

    AggregatedValueSizeRet += ValueSizeRet;
    OCL_ASSERT(
        ValueSizeRet <= AggregatedValueSizeRet,
        "Overflow of variable for storing platform extension names size.");
  }

  // If no extension handles the param_name for object, then return with an
  // error code.
  if (CL_SUCCESS != AggregatedRetcode) {
    return AggregatedRetcode;
  }
  OCL_CHECK(
      nullptr != ParamValue && ParamValueSize < AggregatedValueSizeRet,
      return CL_INVALID_VALUE);

  // Second pass: query the wanted info and store it in the arguments.
  if (nullptr != ParamValue) {
    char *ValueCursor = static_cast<char *>(ParamValue);
    size_t ValueSizeRemaining = ParamValueSize;

    for (size_t ExtIdx = 0; ExtIdx < NumExtensions; ++ExtIdx) {
      cl_int Retcode = GetInfoFn(Extensions[ExtIdx], Object, ParamName, 0,
                                   nullptr, nullptr);
      if (CL_SUCCESS != Retcode) {
        // This extension does not support the info query, keep searching.
        continue;
      }

      size_t ValueSizeRet = 0;
      Retcode =
          GetInfoFn(Extensions[ExtIdx], Object, ParamName,
                      ValueSizeRemaining, ValueCursor, &ValueSizeRet);
      OCL_ASSERT(CL_SUCCESS == Retcode,
                 "Second pass through extension information should not fail.");
      OCL_ASSERT(
          ValueSizeRet <= ValueSizeRemaining,
          "Sizes must not add up differently between first and second pass.");

      ValueCursor += ValueSizeRet;
      ValueSizeRemaining -= ValueSizeRet;
    }
  }

  OCL_SET_IF_NOT_NULL(ParamValueSizeRet, AggregatedValueSizeRet);

  return CL_SUCCESS;
}
}  // namespace

extension::extension::extension(const char *Name, usage_category Usage
#ifdef CL_VERSION_3_0
                                ,
                                cl_version_khr Version
#endif
                                )
    : name(Name),
      usage(Usage)
#ifdef CL_VERSION_3_0
      ,
      version(Version)
#endif
{
  OCL_ASSERT(nullptr != Name || usage_category::DISABLED == Usage,
             "Name required if usage indicates it.");
}

extension::extension::~extension() {}

cl_int extension::extension::GetPlatformInfo(
    cl_platform_id Platform, cl_platform_info ParamName,
    size_t ParamValueSize, void *ParamValue,
    size_t *ParamValueSizeRet) const {
  OCL_UNUSED(Platform);  // Already checked by clGetPlatformInfo.
  if (usage_category::PLATFORM == usage) {
    switch (ParamName) {
      default: {
        return CL_INVALID_VALUE;
      }
      case CL_PLATFORM_EXTENSIONS: {
        const std::size_t Size = name.size() + 1;  // +1 for zero terminator.
        OCL_CHECK(nullptr != ParamValue && ParamValueSize < Size,
                  return CL_INVALID_VALUE);

        if (nullptr != ParamValue) {
          std::memcpy(ParamValue, name.data(), Size);
        }

        OCL_SET_IF_NOT_NULL(ParamValueSizeRet, Size);

        return CL_SUCCESS;
      }
#ifdef CL_VERSION_3_0
      case CL_PLATFORM_EXTENSIONS_WITH_VERSION: {
        size_t PlatformExtensionsSize{};
        GetPlatformInfo(Platform, CL_PLATFORM_EXTENSIONS, 0, nullptr,
                        &PlatformExtensionsSize);
        std::string PlatformExtensions(PlatformExtensionsSize, '\0');
        GetPlatformInfo(Platform, CL_PLATFORM_EXTENSIONS,
                        PlatformExtensions.size(), PlatformExtensions.data(),
                        nullptr);
        auto SplitExtensions = cargo::split(PlatformExtensions, " ");
        auto SizeInBytes =
            SplitExtensions.size() * sizeof(cl_name_version_khr);
        OCL_CHECK(nullptr != ParamValue && (ParamValueSize < SizeInBytes),
                  return CL_INVALID_VALUE);
        cargo::small_vector<cl_name_version_khr, CA_CL_EXTENSION_COUNT>
            NameVersionPairs{};
        if (nullptr != ParamValue) {
          for (const auto &Extension : SplitExtensions) {
            cl_name_version_khr NameVersion{};
            NameVersion.version = version;
            std::memcpy(NameVersion.name, Extension.data(), Extension.size());
            NameVersion.name[Extension.size()] = '\0';
            OCL_UNUSED(NameVersionPairs.push_back(NameVersion));
          }
          std::memcpy(ParamValue, NameVersionPairs.data(), SizeInBytes);
        }
        OCL_SET_IF_NOT_NULL(ParamValueSizeRet, SizeInBytes);
        return CL_SUCCESS;
      }
#endif
    }
  }

  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetDeviceInfo(cl_device_id Device,
                                           cl_device_info ParamName,
                                           size_t ParamValueSize,
                                           void *ParamValue,
                                           size_t *ParamValueSizeRet) const {
  OCL_UNUSED(Device);  // Already checked by clGetDeviceInfo.
  if (usage_category::DEVICE == usage || usage_category::PLATFORM == usage) {
    // If this is a compiler extension and no compiler is available, then
    // disable it.
    if (!Device->compiler_available) {
      auto CompilerExtensions = getCompilerExtensions();
      if (std::find(CompilerExtensions.begin(), CompilerExtensions.end(),
                    this) != CompilerExtensions.end()) {
        return CL_INVALID_DEVICE;
      }
    }
    switch (ParamName) {
      default: {
        return CL_INVALID_VALUE;
      }
      case CL_DEVICE_EXTENSIONS: {
        const std::size_t Size = name.size() + 1;
        OCL_CHECK(nullptr != ParamValue && ParamValueSize < Size,
                  return CL_INVALID_VALUE);

        if (nullptr != ParamValue) {
          std::memcpy(ParamValue, name.data(), Size);
        }

        OCL_SET_IF_NOT_NULL(ParamValueSizeRet, Size);

        return CL_SUCCESS;
      }
#ifdef CL_VERSION_3_0
      case CL_DEVICE_EXTENSIONS_WITH_VERSION: {
        size_t DeviceExtensionsSize{};
        GetDeviceInfo(Device, CL_DEVICE_EXTENSIONS, 0, nullptr,
                      &DeviceExtensionsSize);
        std::string DeviceExtensions(DeviceExtensionsSize, '\0');
        GetDeviceInfo(Device, CL_DEVICE_EXTENSIONS, DeviceExtensions.size(),
                      DeviceExtensions.data(), nullptr);
        auto SplitExtensions = cargo::split(DeviceExtensions, " ");
        auto SizeInBytes =
            SplitExtensions.size() * sizeof(cl_name_version_khr);
        OCL_CHECK(nullptr != ParamValue && (ParamValueSize < SizeInBytes),
                  return CL_INVALID_VALUE);
        if (nullptr != ParamValue) {
          cargo::small_vector<cl_name_version_khr, CA_CL_EXTENSION_COUNT>
              NameVersionPairs{};
          for (const auto &Extension : SplitExtensions) {
            cl_name_version_khr NameVersion{};
            NameVersion.version = version;
            std::memcpy(NameVersion.name, Extension.data(), Extension.size());
            NameVersion.name[Extension.size()] = '\0';
            OCL_UNUSED(NameVersionPairs.push_back(NameVersion));
          }
          std::memcpy(ParamValue, NameVersionPairs.data(), SizeInBytes);
        }
        OCL_SET_IF_NOT_NULL(ParamValueSizeRet, SizeInBytes);
        return CL_SUCCESS;
      }
#endif
    }
  }

  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetContextInfo(cl_context, cl_context_info, size_t,
                                            void *, size_t *) const {
  return CL_INVALID_VALUE;
}

cargo::optional<cl_int> extension::extension::ApplyPropertyToCommandQueue(
    cl_command_queue, cl_queue_properties_khr, cl_queue_properties_khr) const {
  return cargo::nullopt;
}

cl_int extension::extension::GetCommandQueueInfo(cl_command_queue,
                                                 cl_command_queue_info, size_t,
                                                 void *, size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetImageInfo(cl_mem, cl_image_info, size_t, void *,
                                          size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetMemObjectInfo(cl_mem, cl_mem_info, size_t,
                                              void *, size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetSamplerInfo(cl_sampler, cl_sampler_info, size_t,
                                            void *, size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetProgramInfo(cl_program, cl_program_info, size_t,
                                            void *, size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetProgramBuildInfo(cl_program, cl_device_id,
                                                 cl_program_build_info, size_t,
                                                 void *, size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetKernelInfo(cl_kernel, cl_kernel_info, size_t,
                                           void *, size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetKernelWorkGroupInfo(cl_kernel, cl_device_id,
                                                    cl_kernel_work_group_info,
                                                    size_t, void *,
                                                    size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::SetKernelArg(cl_kernel, cl_uint, size_t,
                                          const void *) const {
  return CL_INVALID_KERNEL;
}

cl_int extension::extension::GetKernelArgInfo(cl_kernel, cl_uint,
                                              cl_kernel_arg_info, size_t,
                                              void *, size_t *) const {
  return CL_INVALID_VALUE;
}

#ifdef CL_VERSION_3_0
cl_int extension::extension::GetKernelSubGroupInfo(cl_kernel, cl_device_id,
                                                   cl_kernel_sub_group_info,
                                                   size_t, const void *, size_t,
                                                   void *, size_t *) const {
  return CL_INVALID_VALUE;
}
#endif

#if (defined(CL_VERSION_3_0) || \
     defined(OCL_EXTENSION_cl_codeplay_kernel_exec_info))
cl_int extension::extension::SetKernelExecInfo(cl_kernel,
                                               cl_kernel_exec_info_codeplay,
                                               size_t, const void *) const {
  return CL_INVALID_KERNEL;
}
#endif

cl_int extension::extension::GetEventInfo(cl_event, cl_event_info, size_t,
                                          void *, size_t *) const {
  return CL_INVALID_VALUE;
}

cl_int extension::extension::GetEventProfilingInfo(cl_event, cl_profiling_info,
                                                   size_t, void *,
                                                   size_t *) const {
  return CL_INVALID_VALUE;
}

void *extension::extension::GetExtensionFunctionAddressForPlatform(
    cl_platform_id, const char *) const {
  return nullptr;
}

cl_int extension::GetPlatformInfo(cl_platform_id Platform,
                                  cl_platform_info ParamName,
                                  size_t ParamValueSize, void *ParamValue,
                                  size_t *ParamValueSizeRet) {
  cl_int Retcode = CL_INVALID_VALUE;

  auto QueryFn = [](const extension *Extension, cl_platform_id Object,
                     cl_platform_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetPlatformInfo(Object, ParamName, ParamValueSize,
                                      ParamValue, ParamValueSizeRet);
  };

  // Extend with extension related param_names.
  switch (ParamName) {
    case CL_PLATFORM_EXTENSIONS: {
      const char ExtensionNameSeparator = ' ';
      Retcode = getObjectExtensionInfoAggregatedCString(
          getExtensions().size(), getExtensions().data(), Platform, ParamName,
          ParamValueSize, ParamValue, ParamValueSizeRet,
          ExtensionNameSeparator, QueryFn);
      break;
    }
#ifdef CL_VERSION_3_0
    case CL_PLATFORM_EXTENSIONS_WITH_VERSION: {
      Retcode = getObjectExtensionInfoAggregatedArray(
          getExtensions().size(), getExtensions().data(), Platform, ParamName,
          ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
      break;
    }
#endif
    default: {
      // Assuming that yet unknown extension have a single value to query
      // and are not aggregated.
      Retcode = getObjectExtensionInfoSingleValue(
          getExtensions().size(), getExtensions().data(), Platform, ParamName,
          ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
      break;
    }
  }

  return Retcode;
}

cl_int extension::GetDeviceInfo(cl_device_id Device, cl_device_info ParamName,
                                size_t ParamValueSize, void *ParamValue,
                                size_t *ParamValueSizeRet) {
  cl_int Retcode = CL_INVALID_VALUE;

  auto QueryFn = [](const extension *Extension, cl_device_id Object,
                     cl_device_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetDeviceInfo(Object, ParamName, ParamValueSize,
                                    ParamValue, ParamValueSizeRet);
  };

  // Extend with extension related param_names.
  switch (ParamName) {
    case CL_DEVICE_EXTENSIONS: {
      const char ExtensionNameSeparator = ' ';
      Retcode = getObjectExtensionInfoAggregatedCString(
          getExtensions().size(), getExtensions().data(), Device, ParamName,
          ParamValueSize, ParamValue, ParamValueSizeRet,
          ExtensionNameSeparator, QueryFn);
      break;
    }
#ifdef CL_VERSION_3_0
    case CL_DEVICE_EXTENSIONS_WITH_VERSION: {
      Retcode = getObjectExtensionInfoAggregatedArray(
          getExtensions().size(), getExtensions().data(), Device, ParamName,
          ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
      break;
    }
#endif
    default: {
      // Assuming that yet unknown extension have a single value to query
      // and are not aggregated.
      Retcode = getObjectExtensionInfoSingleValue(
          getExtensions().size(), getExtensions().data(), Device, ParamName,
          ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
      break;
    }
  }

  return Retcode;
}

cl_int extension::GetContextInfo(cl_context Context, cl_context_info ParamName,
                                 size_t ParamValueSize, void *ParamValue,
                                 size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_context Object,
                     cl_context_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetContextInfo(Object, ParamName, ParamValueSize,
                                     ParamValue, ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Context, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

cl_int extension::ApplyPropertyToCommandQueue(cl_command_queue CommandQueue,
                                              cl_queue_properties_khr Property,
                                              cl_queue_properties_khr Value) {
  for (const auto *Extension : getExtensions()) {
    if (auto Result = Extension->ApplyPropertyToCommandQueue(CommandQueue,
                                                             Property, Value)) {
      return *Result;
    }
  }
  return CL_INVALID_VALUE;
}

cl_int extension::GetCommandQueueInfo(cl_command_queue CommandQueue,
                                      cl_command_queue_info ParamName,
                                      size_t ParamValueSize,
                                      void *ParamValue,
                                      size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_command_queue Object,
                     cl_command_queue_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetCommandQueueInfo(Object, ParamName, ParamValueSize,
                                          ParamValue, ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), CommandQueue, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

cl_int extension::GetImageInfo(cl_mem Image, cl_image_info ParamName,
                               size_t ParamValueSize, void *ParamValue,
                               size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_mem Object,
                     cl_image_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetImageInfo(Object, ParamName, ParamValueSize,
                                   ParamValue, ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Image, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

cl_int extension::GetMemObjectInfo(cl_mem Memobj, cl_mem_info ParamName,
                                   size_t ParamValueSize, void *ParamValue,
                                   size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_mem Object,
                     cl_mem_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetMemObjectInfo(Object, ParamName, ParamValueSize,
                                       ParamValue, ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Memobj, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

cl_int extension::GetSamplerInfo(cl_sampler Sampler, cl_sampler_info ParamName,
                                 size_t ParamValueSize, void *ParamValue,
                                 size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_sampler Object,
                     cl_sampler_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetSamplerInfo(Object, ParamName, ParamValueSize,
                                     ParamValue, ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Sampler, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

cl_int extension::GetProgramInfo(cl_program Program, cl_program_info ParamName,
                                 size_t ParamValueSize, void *ParamValue,
                                 size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_program Object,
                     cl_program_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetProgramInfo(Object, ParamName, ParamValueSize,
                                     ParamValue, ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Program, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

cl_int extension::GetProgramBuildInfo(cl_program Program, cl_device_id Device,
                                      cl_program_build_info ParamName,
                                      size_t ParamValueSize,
                                      void *ParamValue,
                                      size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_program Object,
                     cl_device_id Detail, cl_program_build_info ParamName,
                     size_t ParamValueSize, void *ParamValue,
                     size_t *ParamValueSizeRet) {
    return Extension->GetProgramBuildInfo(Object, Detail, ParamName,
                                          ParamValueSize, ParamValue,
                                          ParamValueSizeRet);
  };

  return getObjectDetailExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Program, Device,
      ParamName, ParamValueSize, ParamValue, ParamValueSizeRet,
      QueryFn);
}

cl_int extension::GetKernelInfo(cl_kernel Kernel, cl_kernel_info ParamName,
                                size_t ParamValueSize, void *ParamValue,
                                size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_kernel Object,
                     cl_kernel_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetKernelInfo(Object, ParamName, ParamValueSize,
                                    ParamValue, ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Kernel, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

cl_int extension::GetKernelWorkGroupInfo(cl_kernel Kernel, cl_device_id Device,
                                         cl_kernel_work_group_info ParamName,
                                         size_t ParamValueSize,
                                         void *ParamValue,
                                         size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_kernel Object,
                     cl_device_id Detail, cl_kernel_work_group_info ParamName,
                     size_t ParamValueSize, void *ParamValue,
                     size_t *ParamValueSizeRet) {
    return Extension->GetKernelWorkGroupInfo(Object, Detail, ParamName,
                                             ParamValueSize, ParamValue,
                                             ParamValueSizeRet);
  };

  return getObjectDetailExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Kernel, Device,
      ParamName, ParamValueSize, ParamValue, ParamValueSizeRet,
      QueryFn);
}

cl_int extension::SetKernelArg(cl_kernel Kernel, cl_uint ArgIndex,
                               size_t ArgSize, const void *ArgValue) {
  for (const auto *Extension : getExtensions()) {
    auto Error =
        Extension->SetKernelArg(Kernel, ArgIndex, ArgSize, ArgValue);
    if (Error != CL_INVALID_KERNEL) {
      return Error;
    }
  }
  return CL_INVALID_KERNEL;
}

cl_int extension::GetKernelArgInfo(cl_kernel Kernel, cl_uint ArgIndx,
                                   cl_kernel_arg_info ParamName,
                                   size_t ParamValueSize, void *ParamValue,
                                   size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_kernel Object,
                     cl_uint Detail, cl_kernel_arg_info ParamName,
                     size_t ParamValueSize, void *ParamValue,
                     size_t *ParamValueSizeRet) {
    return Extension->GetKernelArgInfo(Object, Detail, ParamName,
                                       ParamValueSize, ParamValue,
                                       ParamValueSizeRet);
  };

  return getObjectDetailExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Kernel, ArgIndx,
      ParamName, ParamValueSize, ParamValue, ParamValueSizeRet,
      QueryFn);
}

#ifdef CL_VERSION_3_0
cl_int extension::GetKernelSubGroupInfo(
    cl_kernel Kernel, cl_device_id Device, cl_kernel_sub_group_info ParamName,
    size_t InputValueSize, const void *InputValue, size_t ParamValueSize,
    void *ParamValue, size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_kernel Object,
                     cl_device_id Detail, cl_kernel_sub_group_info ParamName,
                     size_t InputValueSize, const void *InputValue,
                     size_t ParamValueSize, void *ParamValue,
                     size_t *ParamValueSizeRet) {
    return Extension->GetKernelSubGroupInfo(
        Object, Detail, ParamName, InputValueSize, InputValue,
        ParamValueSize, ParamValue, ParamValueSizeRet);
  };

  return getObjectDetailExtensionInfoSingleInputValue(
      getExtensions().size(), getExtensions().data(), Kernel, Device,
      ParamName, InputValueSize, InputValue, ParamValueSize, ParamValue,
      ParamValueSizeRet, QueryFn);
}
#endif

#if (defined(CL_VERSION_3_0) || \
     defined(OCL_EXTENSION_cl_codeplay_kernel_exec_info))
cl_int extension::SetKernelExecInfo(cl_kernel Kernel,
                                    cl_kernel_exec_info_codeplay ParamName,
                                    size_t ParamValueSize,
                                    const void *ParamValue) {
  for (const auto *Extension : getExtensions()) {
    auto Error = Extension->SetKernelExecInfo(Kernel, ParamName,
                                              ParamValueSize, ParamValue);
    if (Error != CL_INVALID_KERNEL) {
      return Error;
    }
  }
  return CL_INVALID_KERNEL;
}
#endif

cl_int extension::GetEventInfo(cl_event Event, cl_event_info ParamName,
                               size_t ParamValueSize, void *ParamValue,
                               size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_event Object,
                     cl_event_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetEventInfo(Object, ParamName, ParamValueSize,
                                   ParamValue, ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Event, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

cl_int extension::GetEventProfilingInfo(cl_event Event,
                                        cl_profiling_info ParamName,
                                        size_t ParamValueSize,
                                        void *ParamValue,
                                        size_t *ParamValueSizeRet) {
  auto QueryFn = [](const extension *Extension, cl_event Object,
                     cl_profiling_info ParamName, size_t ParamValueSize,
                     void *ParamValue, size_t *ParamValueSizeRet) {
    return Extension->GetEventProfilingInfo(Object, ParamName,
                                            ParamValueSize, ParamValue,
                                            ParamValueSizeRet);
  };

  return getObjectExtensionInfoSingleValue(
      getExtensions().size(), getExtensions().data(), Event, ParamName,
      ParamValueSize, ParamValue, ParamValueSizeRet, QueryFn);
}

void *extension::GetExtensionFunctionAddressForPlatform(cl_platform_id Platform,
                                                        const char *FuncName) {
  return ::getExtensionFunctionAddressForPlatform(
      getExtensions().size(), getExtensions().data(), Platform, FuncName);
}

[[nodiscard]] cl_int extension::GetRuntimeExtensionsForDevice(
    cl_device_id Device, cargo::string_view &ExtensionsRet) {
  static std::string Extensions{};
  static std::once_flag InitializedFlag{};
  static cl_int Retcode = CL_SUCCESS;

  std::call_once(InitializedFlag, [&]() {
    auto QueryFn = [](const extension *Extension, cl_device_id Object,
                       cl_device_info ParamName, size_t ParamValueSize,
                       void *ParamValue, size_t *ParamValueSizeRet) {
      return Extension->GetDeviceInfo(Object, ParamName, ParamValueSize,
                                      ParamValue, ParamValueSizeRet);
    };

    size_t ExtStringLength = 0;
    Retcode = getObjectExtensionInfoAggregatedCString(
        getRuntimeExtensions().size(), getRuntimeExtensions().data(), Device,
        CL_DEVICE_EXTENSIONS, 0, nullptr, &ExtStringLength, ' ', QueryFn);

    // CL_INVALID_VALUE indicates that the device supports no extensions
    if (CL_INVALID_VALUE == Retcode) {
      Retcode = CL_SUCCESS;
      return;
    }
    if (CL_SUCCESS != Retcode) {
      return;
    }

    Extensions = std::string(ExtStringLength, '\0');
    Retcode = getObjectExtensionInfoAggregatedCString(
        getRuntimeExtensions().size(), getRuntimeExtensions().data(), Device,
        CL_DEVICE_EXTENSIONS, ExtStringLength, Extensions.data(), nullptr,
        ' ', QueryFn);
    if (CL_SUCCESS != Retcode) {
      return;
    }
  });

  if (CL_SUCCESS == Retcode) {
    ExtensionsRet = cargo::string_view(Extensions.data(), Extensions.size());
  }

  return Retcode;
}

[[nodiscard]] cl_int extension::GetCompilerExtensionsForDevice(
    cl_device_id Device, cargo::string_view &ExtensionsRet) {
  static std::string Extensions{};
  static std::once_flag InitializedFlag{};
  static cl_int Retcode = CL_SUCCESS;

  std::call_once(InitializedFlag, [&]() {
    auto QueryFn = [](const extension *Extension, cl_device_id Object,
                       cl_device_info ParamName, size_t ParamValueSize,
                       void *ParamValue, size_t *ParamValueSizeRet) {
      return Extension->GetDeviceInfo(Object, ParamName, ParamValueSize,
                                      ParamValue, ParamValueSizeRet);
    };

    size_t ExtStringLength = 0;
    Retcode = getObjectExtensionInfoAggregatedCString(
        getCompilerExtensions().size(), getCompilerExtensions().data(), Device,
        CL_DEVICE_EXTENSIONS, 0, nullptr, &ExtStringLength, ' ', QueryFn);

    // CL_INVALID_VALUE indicates that the device supports no etensions
    if (CL_INVALID_VALUE == Retcode) {
      Retcode = CL_SUCCESS;
      return;
    }
    if (CL_SUCCESS != Retcode) {
      return;
    }

    Extensions = std::string(ExtStringLength, '\0');
    Retcode = getObjectExtensionInfoAggregatedCString(
        getCompilerExtensions().size(), getCompilerExtensions().data(), Device,
        CL_DEVICE_EXTENSIONS, ExtStringLength, Extensions.data(), nullptr,
        ' ', QueryFn);
    if (CL_SUCCESS != Retcode) {
      return;
    }
  });

  if (CL_SUCCESS == Retcode) {
    ExtensionsRet = cargo::string_view(Extensions.data(), Extensions.size());
  }

  return Retcode;
}
