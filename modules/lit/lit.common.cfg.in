# Copyright (C) Codeplay Software Limited
#
# Licensed under the Apache License, Version 2.0 (the "License") with LLVM
# Exceptions; you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://github.com/uxlfoundation/oneapi-construction-kit/blob/main/LICENSE.txt
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
# @AUTOGENERATED_MESSAGE@

import lit.util
import re
from subprocess import check_output
from platform import system, machine

from lit.llvm.subst import ToolSubst

import lit.llvm
lit.llvm.initialize(lit_config, config)
from lit.llvm import llvm_config

# Import the utils modules from the common lit module
sys.path.insert(0, '@CA_COMMON_LIT_BINARY_PATH@')
import utils.tool_config

def if_enabled(config, if_true=True, if_false=False):
    return lit.util.pythonize_bool(config) and if_true or if_false

config.system_processor = '@CMAKE_SYSTEM_PROCESSOR@'.lower()

config.ca_cross_compiled = if_enabled('@CMAKE_CROSSCOMPILING@')

if '@LLVM_VERSION_MAJOR@':
    config.llvm_version_triple = (
        int(@LLVM_VERSION_MAJOR@),
        int(@LLVM_VERSION_MINOR@),
        int(@LLVM_VERSION_PATCH@),
    )
    config.llvm_version_major = int(@LLVM_VERSION_MAJOR@)
    config.substitutions.append(('%LLVMVER', '@LLVM_VERSION_MAJOR@'))

    config.available_features.add('llvm')
    config.available_features.add('llvm-@LLVM_VERSION_MAJOR@.@LLVM_VERSION_MINOR@-only')

    # Add all previous LLVM major versions as features too, e.g., llvm-10+
    # matches on LLVMs 10,11,12,13 and onwards.
    for ver in range(8, @LLVM_VERSION_MAJOR@ + 1):
        config.available_features.add('llvm-{0}+'.format(ver))

config.targets = frozenset('@LLVM_TARGETS_TO_BUILD@'.split(';'))

config.llvm_enable_stats = (
    if_enabled('@LLVM_ENABLE_ASSERTIONS@') or
    if_enabled('@LLVM_FORCE_ENABLE_STATS@')
)

if if_enabled('@LLVM_ENABLE_ASSERTIONS@'):
    config.available_features.add('asserts')
if if_enabled('@CA_ENABLE_DEBUG_SUPPORT@'):
    config.available_features.add('debug')

# Some lit tests may fail when cross-compiled, so add the native feature if not
# cross-compiling.
if not config.ca_cross_compiled:
    config.available_features.add('native')

def is_compile_flag_defined(options_str, flag):
    is_enabled = False
    opts = options_str.split()
    for i, opt in enumerate(opts):
        if opt in (f'-D{flag}', f'/D{flag}') or \
                (opt == '/D' and i + 1 < len(opts) and opts[i + 1] == flag):
            is_enabled = True
        elif opt == f'-U{flag}':
            is_enabled = False
    return is_enabled

cmake_cxx_flags = '@CMAKE_CXX_FLAGS@'

if not is_compile_flag_defined(cmake_cxx_flags, 'NDEBUG') or if_enabled('@CA_ENABLE_LLVM_OPTIONS_IN_RELEASE@'):
    config.available_features.add('ca_llvm_options')

if system() == 'Linux':
    config.available_features.add('linux')
elif system() == 'arm':
    config.available_features.add('arm')

if config.system_processor in ('x86_64', 'x64', 'amd64'):
    config.available_features.add('x86_64')
elif config.system_processor in ('x86', 'i686'):
    config.available_features.add('x86')
elif config.system_processor in ('aarch64', 'arm64'):
    config.available_features.add('aarch64')
elif config.system_processor in ('arm', 'armv7'):
    config.available_features.add('arm32')

config.ca_host_os = '@CMAKE_SYSTEM_NAME@'

config.ca_host_bits = 64 if (
    @CMAKE_SIZEOF_VOID_P@ == 8 and
    ('@CA_BUILD_32_BITS@' != 'ON' or '@CMAKE_CL_64@' == '1')
) else 32


# Check we can find helper tools, otherwise raise an exception
# to prevent any tests running.

# We allow sites to define config.tools first, but don't require it.
if 'tools' not in vars(config):
    config.tools = []

# Extend any site tool with our standard set of tools. If any of these are
# missing, we mark the whole test suite as unsupported.
config.tools.extend([
    ToolSubst('not', unresolved='ignore'),
    ToolSubst('FileCheck', unresolved='ignore'),
    ToolSubst('llc', unresolved='ignore'),
    ToolSubst('llvm-as', unresolved='ignore'),
    ToolSubst('llvm-dis', unresolved='ignore'),
])

# The add_tool_substitutions functiom below requires us to have a
# llvm_tools_dir set, so we set it to the most sensible choice of the tool
# directories we search.
config.llvm_tools_dir = '@CA_LLVM_TOOLS_DIR@'

# Try and find each of these tools in the various tools directories or the
# PATH, in that order. If found, they will be added as substitutions with the
# full path to the tool. This allows us to support both in-tree builds and
# standalone builds, where the tools may be externally defined.
config.tool_search_dirs = [
    '@PROJECT_BINARY_DIR@/bin', '@CA_BUILTINS_TOOLS_DIR@',
     config.llvm_tools_dir, os.environ.get('PATH', ''),
]

# Define substitutions to the tools we use
utils.tool_config.add_ca_tool_substitutions(config, lit_config, llvm_config, config.tools)

unresolved_tools = utils.tool_config.get_unresolved_tools(config.tools)
skip_if_missing_tools = lit.util.pythonize_bool(lit_config.params.get("skip_if_missing_tools", None))

if unresolved_tools and skip_if_missing_tools:
    config.unsupported = True
    lit_config.note(f'Skipping test suite: did not find {",".join(unresolved_tools)} in {config.tool_search_dirs}')

config.substitutions += [
    ('%python', sys.executable),
    ('%pp-llvm-ver', '%s %s' % (
        sys.executable,
        os.path.join('@PROJECT_SOURCE_DIR@', 'scripts', 'testing', 'pp-llvm-ver.py')
    ))
]
