/// @brief Compare of x == y.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise compare of x == y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isequal.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isequal(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isequal.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isequal(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_isequal(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x != y.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise compare of x != y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnotequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnotequal.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isnotequal(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isnotequal.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isnotequal(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_isnotequal(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x > y.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise compare of x > y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreater.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isgreater(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isgreater.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isgreater(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_isgreater(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x >= y.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise compare of x >= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isgreaterequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isgreaterequal.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isgreaterequal(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isgreaterequal.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isgreaterequal(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_isgreaterequal(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x < y.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise compare of x < y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isless.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isless.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isless(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isless.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isless(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_isless(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of x <= y.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise compare of x <= y. For scalar types, 1 or 0 is 
/// returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessequal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessequal.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_islessequal(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_islessequal.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API islessequal(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_islessequal(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Compare of (x < y) || (x > y).
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise compare of (x < y) || (x > y). For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 islessgreater.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/islessgreater.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_islessgreater(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_islessgreater.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API islessgreater(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_islessgreater(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for finite value.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise test for finite value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isfinite.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isfinite.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isfinite(abacus_@generate_type@ x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isfinite.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isfinite(abacus_@generate_type@ x) {
  return __abacus_isfinite(x);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for infinity value.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise test for infinity value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isinf.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isinf.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isinf(abacus_@generate_type@ x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isinf.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isinf(abacus_@generate_type@ x) {
  return __abacus_isinf(x);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for NaN value.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise test for Not-a-Number value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnan.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnan.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isnan(abacus_@generate_type@ x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isnan.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isnan(abacus_@generate_type@ x) {
  return __abacus_isnan(x);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for a normal value.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise test for a normal value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isnormal.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isnormal.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isnormal(abacus_@generate_type@ x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isnormal.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isnormal(abacus_@generate_type@ x) {
  return __abacus_isnormal(x);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are ordered.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise test for ordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isordered.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isordered(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isordered.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isordered(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_isordered(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test is arguments are unordered.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise test for unordered arguments. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 isunordered.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/isunordered.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_isunordered(abacus_@generate_type@ x, abacus_@generate_type@ y);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_isunordered.
/// @param[in] x A abacus_@generate_type@.
/// @param[in] y A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API isunordered(abacus_@generate_type@ x, abacus_@generate_type@ y) {
  return __abacus_isunordered(x, y);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Test for sign bit.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Returns the component-wise test for a signed value. For scalar types,
/// 1 or 0 is returned. For vector types, -1 or 0 is returned.
///
/// Standards compliant implementation of OpenCL 1.2 signbit.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/signbit.html
abacus_@generate_signed_type@ ABACUS_EXPORT_API __abacus_signbit(abacus_@generate_type@ x);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_signbit.
/// @param[in] x A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_signed_type@ ABACUS_API signbit(abacus_@generate_type@ x) {
  return __abacus_signbit(x);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_@generate_type@.
/// @param[in] b A abacus_@generate_type@.
/// @param[in] c A abacus_@generate_type@.
/// @return      A abacus_@generate_signed_type@.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_@generate_type@ ABACUS_EXPORT_API __abacus_select(abacus_@generate_type@ a, abacus_@generate_type@ b, abacus_@generate_signed_same_size_type@ c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_@generate_type@.
/// @param[in] b A abacus_@generate_type@.
/// @param[in] c A abacus_@generate_signed_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_type@ ABACUS_API select(abacus_@generate_type@ a, abacus_@generate_type@ b, abacus_@generate_signed_same_size_type@ c) {
  return __abacus_select(a, b, c);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Select from a and b, based on most significant bit of c.
/// @param[in] a A abacus_@generate_type@.
/// @param[in] b A abacus_@generate_type@.
/// @param[in] c A abacus_@generate_type@.
/// @return      A abacus_u@generate_signed_type@.
///
/// For each component of a vector type, result[i] = if most significant bit of 
/// c[i] is set ?  b[i] : a[i] For scalar type, result = c ? b : a.
///
/// Standards compliant implementation of OpenCL 1.2 select.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/select.html
abacus_@generate_type@ ABACUS_EXPORT_API __abacus_select(abacus_@generate_type@ a, abacus_@generate_type@ b, abacus_u@generate_signed_same_size_type@ c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_select.
/// @param[in] a A abacus_@generate_type@.
/// @param[in] b A abacus_@generate_type@.
/// @param[in] c A abacus_u@generate_signed_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_type@ ABACUS_API select(abacus_@generate_type@ a, abacus_@generate_type@ b, abacus_u@generate_signed_same_size_type@ c) {
  return __abacus_select(a, b, c);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif

/// @brief Bit select from a and b, based on bits in c.
/// @param[in] a A abacus_@generate_type@.
/// @param[in] b A abacus_@generate_type@.
/// @param[in] c A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
///
/// Each bit of result is corresponding bit of a if corresponding bit of c is 0.
///
/// Standards compliant implementation of OpenCL 1.2 bitselect.
///
/// @see https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/bitselect.html
abacus_@generate_type@ ABACUS_EXPORT_API __abacus_bitselect(abacus_@generate_type@ a, abacus_@generate_type@ b, abacus_@generate_type@ c);

#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
namespace abacus {
#endif
#if defined(ABACUS_ENABLE_OPENCL_1_2_BUILTINS)
/// @brief Wrapper for __abacus_bitselect.
/// @param[in] a A abacus_@generate_type@.
/// @param[in] b A abacus_@generate_type@.
/// @param[in] c A abacus_@generate_type@.
/// @return      A abacus_@generate_type@.
inline abacus_@generate_type@ ABACUS_API bitselect(abacus_@generate_type@ a, abacus_@generate_type@ b, abacus_@generate_type@ c) {
  return __abacus_bitselect(a, b, c);
}
#endif
#if defined(__cplusplus) && !defined(__OPENCL_VERSION__)
}
#endif


