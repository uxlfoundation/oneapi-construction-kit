#!/bin/bash

signedinttypes="char short int long"
unsignedinttypes="uchar ushort uint ulong"
inttypes="$signedinttypes $unsignedinttypes"
floattypes="half float double"
alltypes="$inttypes $floattypes"
nonconstantaddresses="private global local"
addresses="$nonconstantaddresses constant"
sizes="1 2 3 4 8 16"
roundingmodes="rte rtz rtn rtp"

# generated_output_type can be one of; header, cxx, cl
generated_output_type=

function check_bin {
  which $* &> /dev/null
}

function header()
{
  echo "// Copyright (C) Codeplay Software Limited"
  echo "//"
  echo "// Licensed under the Apache License, Version 2.0 (the \"License\") with LLVM"
  echo "// Exceptions; you may not use this file except in compliance with the License."
  echo "// You may obtain a copy of the License at"
  echo "//"
  echo "//     https://github.com/codeplaysoftware/oneapi-construction-kit/blob/main/LICENSE.txt"
  echo "//"
  echo "// Unless required by applicable law or agreed to in writing, software"
  echo "// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT"
  echo "// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the"
  echo "// License for the specific language governing permissions and limitations"
  echo "// under the License."
  echo "//"
  echo "// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception"
  echo "//"
  echo "// WARNING: This file is generated by a script, do not edit it directly. Instead"
  echo "// changes should be made to the generate_header.sh script in builtins/scripts."
  echo ""
  if [[ "header" == "$generated_output_type" ]]
  then
    echo "#ifndef __CODEPLAY_BUILTINS_H__"
    echo "#define __CODEPLAY_BUILTINS_H__"
  fi

  if [[ "cxx" == "$generated_output_type" ]]
  then
    echo '#include <builtins/builtins.h>'
    echo '#include <builtins/cxxbuiltins.h>'
  elif [[ "cl" == "$generated_output_type" ]]
  then
    echo '#include <builtins/builtins.h>'
    echo '#define ABACUS_ENABLE_OPENCL_1_2_BUILTINS'
    echo '#include <builtins/clbuiltins.h>'
    echo '#undef ABACUS_ENABLE_OPENCL_1_2_BUILTINS'
  fi

  echo "#ifdef __cplusplus"
  echo 'extern "C" {'
  echo "#endif"
}

function footer()
{
  if [[ "cxx" == "$generated_output_type" ]]
  then
    echo 'void *memcpy(void *__restrict dst, const void *__restrict src, size_t num) {'
    echo '  auto *d = static_cast<unsigned char *>(dst);'
    echo '  auto *s = static_cast<const unsigned char *>(src);'
    echo '  while (num--) {'
    echo '    *(d++) = *(s++);'
    echo '  }'
    echo '  return dst;'
    echo '}'
    echo ''
    echo 'void *memmove(void *dst, const void *src, size_t num) {'
    echo '  if (reinterpret_cast<uintptr_t>(static_cast<char *>(dst) + num) <='
    echo '          reinterpret_cast<uintptr_t>(src) ||'
    echo '      reinterpret_cast<uintptr_t>(static_cast<const char *>(src) + num) <='
    echo '          reinterpret_cast<uintptr_t>(dst)) {'
    echo '    return memcpy(dst, src, num);'
    echo '  }'
    echo '  if (reinterpret_cast<uintptr_t>(dst) < reinterpret_cast<uintptr_t>(src)) {'
    echo '    auto *d = static_cast<unsigned char *>(dst);'
    echo '    auto *s = static_cast<const unsigned char *>(src);'
    echo '    while (num--) {'
    echo '      *(d++) = *(s++);'
    echo '    }'
    echo '  }'
    echo '  if (reinterpret_cast<uintptr_t>(src) < reinterpret_cast<uintptr_t>(dst)) {'
    echo '    auto *d = static_cast<unsigned char *>(dst) + num;'
    echo '    auto *s = static_cast<const unsigned char *>(src) + num;'
    echo '    while (num--) {'
    echo '      *(--d) = *(--s);'
    echo '    }'
    echo '  }'
    echo '  return dst;'
    echo '}'
    echo ''
    echo 'void *memset(void *ptr, int value, size_t num) {'
    echo '  unsigned char *dst = static_cast<unsigned char *>(ptr);'
    echo '  while (num--) {'
    echo '    *(dst++) = (unsigned char)value;'
    echo '  }'
    echo '  return ptr;'
    echo '}'
    echo ''
  fi
  echo "#ifdef __cplusplus"
  echo "};"
  echo "#endif"
  echo ""
  if [[ "header" == "$generated_output_type" ]]
  then
    echo "#endif  // __CODEPLAY_BUILTINS_H__"
    echo ""
  fi
}

function sand_line()
{
  echo ""
  echo "/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/"
  echo ""
}

function half_support_begin()
{
  if [[ "$1" == "half"* ]]
  then
    echo "#ifdef __CA_BUILTINS_HALF_SUPPORT"
  fi
}

function half_support_end()
{
  if [[ "$1" == "half"* ]]
  then
    echo "#endif  // __CA_BUILTINS_HALF_SUPPORT"
  fi
}

function double_support_begin()
{
  if [[ "$1" == "double"* ]]
  then
    echo "#ifdef __CA_BUILTINS_DOUBLE_SUPPORT"
  fi
}

function double_support_end()
{
  if [[ "$1" == "double"* ]]
  then
    echo "#endif // __CA_BUILTINS_DOUBLE_SUPPORT"
  fi
}

function force_cxx_unsafe_begin()
{
  echo "#ifndef __cplusplus"
}

function force_cxx_unsafe_end()
{
  echo "#endif//__cplusplus"
}

function cxx_unsafe_begin()
{
  [[ "cxx" != "$generated_output_type" ]] && force_cxx_unsafe_begin
}

function cxx_unsafe_end()
{
  [[ "cxx" != "$generated_output_type" ]] && force_cxx_unsafe_end
}

function all_typedefs()
{
  if [[ "header" == "$generated_output_type" ]]
  then
    echo "#define CL_VERSION_1_0 100"
    echo "#define CL_VERSION_1_1 110"
    echo "#define CL_VERSION_1_2 120"
    echo "#define __OPENCL_VERSION__ CL_VERSION_1_2"
    echo "#define __kernel_exec(X, typen) __kernel __attribute__((work_group_size_hint(X, 1, 1))) __attribute__((vec_type_hint(typen)))"
    echo "#define kernel_exec(X, typen) __kernel_exec(X, typen)"

    echo "#ifdef __cplusplus"
    echo "#define private"
    echo "#define __private private"
    echo "#define global __attribute__((address_space(1)))"
    echo "#define __global global"
    echo "#define constant __attribute__((address_space(2)))"
    echo "#define __constant constant"
    echo "#define local __attribute__((address_space(3)))"
    echo "#define __local local"
    echo "#endif//__cplusplus"

    echo "#ifdef __CA_BUILTINS_HALF_SUPPORT"
    echo "#ifdef __cplusplus"
    echo "typedef _Float16 half;"
    echo "#else"
    echo "#pragma OPENCL EXTENSION cl_khr_fp16 : enable"
    echo "#endif // __cplusplus"
    echo "#endif // __CA_BUILTINS_HALF_SUPPORT"

    echo "#ifndef __cplusplus"
    echo "#ifdef __CA_BUILTINS_DOUBLE_SUPPORT"
    echo "#pragma OPENCL EXTENSION cl_khr_fp64 : enable"
    echo "#else"
    echo "#pragma OPENCL EXTENSION cl_khr_fp64 : disable"
    echo "#endif // __CA_BUILTINS_DOUBLE_SUPPORT"
    echo "#endif // __cplusplus"

    echo "typedef unsigned char uchar;"
    echo "typedef unsigned short ushort;"
    echo "typedef unsigned int uint;"
    echo "typedef unsigned long ulong;"
    echo "#if defined(__SPIR64__)"
    echo "typedef ulong size_t;"
    echo "typedef long ptrdiff_t;"
    echo "#elif defined(__SPIR32__)"
    echo "typedef uint size_t;"
    echo "typedef int ptrdiff_t;"
    echo "#else"
    echo "#error Unknown SPIR mode specified!"
    echo "#endif"
    echo "typedef ptrdiff_t intptr_t;"
    echo "typedef size_t uintptr_t;"

    echo "typedef char char2 __attribute__((ext_vector_type(2)));"
    echo "typedef char char3 __attribute__((ext_vector_type(3)));"
    echo "typedef char char4 __attribute__((ext_vector_type(4)));"
    echo "typedef char char8 __attribute__((ext_vector_type(8)));"
    echo "typedef char char16 __attribute__((ext_vector_type(16)));"

    echo "typedef uchar uchar2 __attribute__((ext_vector_type(2)));"
    echo "typedef uchar uchar3 __attribute__((ext_vector_type(3)));"
    echo "typedef uchar uchar4 __attribute__((ext_vector_type(4)));"
    echo "typedef uchar uchar8 __attribute__((ext_vector_type(8)));"
    echo "typedef uchar uchar16 __attribute__((ext_vector_type(16)));"

    echo "typedef short short2 __attribute__((ext_vector_type(2)));"
    echo "typedef short short3 __attribute__((ext_vector_type(3)));"
    echo "typedef short short4 __attribute__((ext_vector_type(4)));"
    echo "typedef short short8 __attribute__((ext_vector_type(8)));"
    echo "typedef short short16 __attribute__((ext_vector_type(16)));"

    echo "typedef ushort ushort2 __attribute__((ext_vector_type(2)));"
    echo "typedef ushort ushort3 __attribute__((ext_vector_type(3)));"
    echo "typedef ushort ushort4 __attribute__((ext_vector_type(4)));"
    echo "typedef ushort ushort8 __attribute__((ext_vector_type(8)));"
    echo "typedef ushort ushort16 __attribute__((ext_vector_type(16)));"

    echo "typedef int int2 __attribute__((ext_vector_type(2)));"
    echo "typedef int int3 __attribute__((ext_vector_type(3)));"
    echo "typedef int int4 __attribute__((ext_vector_type(4)));"
    echo "typedef int int8 __attribute__((ext_vector_type(8)));"
    echo "typedef int int16 __attribute__((ext_vector_type(16)));"

    echo "typedef uint uint2 __attribute__((ext_vector_type(2)));"
    echo "typedef uint uint3 __attribute__((ext_vector_type(3)));"
    echo "typedef uint uint4 __attribute__((ext_vector_type(4)));"
    echo "typedef uint uint8 __attribute__((ext_vector_type(8)));"
    echo "typedef uint uint16 __attribute__((ext_vector_type(16)));"

    echo "#ifdef __CA_BUILTINS_HALF_SUPPORT"
    echo "typedef half half2 __attribute__((ext_vector_type(2)));"
    echo "typedef half half3 __attribute__((ext_vector_type(3)));"
    echo "typedef half half4 __attribute__((ext_vector_type(4)));"
    echo "typedef half half8 __attribute__((ext_vector_type(8)));"
    echo "typedef half half16 __attribute__((ext_vector_type(16)));"
    echo "#endif"

    echo "typedef float float2 __attribute__((ext_vector_type(2)));"
    echo "typedef float float3 __attribute__((ext_vector_type(3)));"
    echo "typedef float float4 __attribute__((ext_vector_type(4)));"
    echo "typedef float float8 __attribute__((ext_vector_type(8)));"
    echo "typedef float float16 __attribute__((ext_vector_type(16)));"

    echo "#ifdef __CA_BUILTINS_DOUBLE_SUPPORT"
    echo "typedef double double2 __attribute__((ext_vector_type(2)));"
    echo "typedef double double3 __attribute__((ext_vector_type(3)));"
    echo "typedef double double4 __attribute__((ext_vector_type(4)));"
    echo "typedef double double8 __attribute__((ext_vector_type(8)));"
    echo "typedef double double16 __attribute__((ext_vector_type(16)));"
    echo "#endif // __CA_BUILTINS_DOUBLE_SUPPORT"

    echo "typedef long long2 __attribute__((ext_vector_type(2)));"
    echo "typedef long long3 __attribute__((ext_vector_type(3)));"
    echo "typedef long long4 __attribute__((ext_vector_type(4)));"
    echo "typedef long long8 __attribute__((ext_vector_type(8)));"
    echo "typedef long long16 __attribute__((ext_vector_type(16)));"

    echo "typedef ulong ulong2 __attribute__((ext_vector_type(2)));"
    echo "typedef ulong ulong3 __attribute__((ext_vector_type(3)));"
    echo "typedef ulong ulong4 __attribute__((ext_vector_type(4)));"
    echo "typedef ulong ulong8 __attribute__((ext_vector_type(8)));"
    echo "typedef ulong ulong16 __attribute__((ext_vector_type(16)));"

    # All OpenCL builtins need to be overloaded based on memory spaces, so set
    # that attribute. Note that this is not an official OpenCL attribute, but
    # as we control the compiler, we know that it works. Some functions, e.g.,
    # barriers, should also be handled carefully by LLVM optimizations, so set
    # the convergent attribute. Recent Clang releases will set convergent on
    # barriers by default, so us doing it may not be strictly necessary.
    echo '#define __CL_CONST_ATTRIBUTES __attribute__((overloadable,const,nothrow))'
    echo '#define __CL_BUILTIN_ATTRIBUTES __attribute__((overloadable,nothrow))'
    echo '#define __CL_WORK_ITEM_ATTRIBUTES __attribute__((overloadable,pure,nothrow))'
    echo '#define __CL_BARRIER_ATTRIBUTES __attribute__((overloadable,convergent,nothrow))'

    # 'restrict' is 'restrict' in OpenCL C, but '__restrict' in C++.  Defining
    # the word restrict here prevents its use as an identifier name, but
    # crucially only in ComputeAorta builtin code, not in user-written code.
    echo '#ifdef __cplusplus'
    echo '#define restrict __restrict'
    echo '#endif'

    echo "#ifdef __CA_BUILTINS_HALF_SUPPORT"
    echo "#define HALF_DIG        3"
    echo "#define HALF_MANT_DIG   11"
    echo "#define HALF_MAX_10_EXP +4"
    echo "#define HALF_MAX_EXP    +16"
    echo "#define HALF_MIN_10_EXP -4"
    echo "#define HALF_MIN_EXP    -13"
    echo "#define HALF_RADIX      2"
    echo "#define HALF_MAX        0x1.ffcp15h"
    echo "#define HALF_MIN        0x1.0p-14h"
    echo "#define HALF_EPSILON    0x1.0p-10h"
    echo "#endif"

    echo "#define FLT_DIG        6"
    echo "#define FLT_MANT_DIG   24"
    echo "#define FLT_MAX_10_EXP +38"
    echo "#define FLT_MAX_EXP    +128"
    echo "#define FLT_MIN_10_EXP -37"
    echo "#define FLT_MIN_EXP    -125"
    echo "#define FLT_RADIX      2"
    echo "#define FLT_MAX        0x1.fffffep127f"
    echo "#define FLT_MIN        0x1.0p-126f"
    echo "#define FLT_EPSILON    0x1.0p-23f"

    echo "#ifdef __CA_BUILTINS_DOUBLE_SUPPORT"
    echo "#define DBL_DIG        15"
    echo "#define DBL_MANT_DIG   53"
    echo "#define DBL_MAX_10_EXP +308"
    echo "#define DBL_MAX_EXP    +1024"
    echo "#define DBL_MIN_10_EXP -307"
    echo "#define DBL_MIN_EXP    -1021"
    echo "#define DBL_RADIX      2"
    echo "#define DBL_MAX        0x1.fffffffffffffp1023"
    echo "#define DBL_MIN        0x1.0p-1022"
    echo "#define DBL_EPSILON    0x1.0p-52"
    echo "#endif // __CA_BUILTINS_DOUBLE_SUPPORT"

    echo "#define CHAR_BIT       8"
    echo "#define CHAR_MAX       SCHAR_MAX"
    echo "#define CHAR_MIN       SCHAR_MIN"
    echo "#define INT_MAX        2147483647"
    echo "#define INT_MIN        (-2147483647- 1)"
    echo "#define LONG_MAX       0x7fffffffffffffffL"
    echo "#define LONG_MIN       (-0x7fffffffffffffffL- 1)"
    echo "#define SCHAR_MAX      127"
    echo "#define SCHAR_MIN      (-127 - 1)"
    echo "#define SHRT_MAX       32767"
    echo "#define SHRT_MIN       (-32767- 1)"
    echo "#define UCHAR_MAX      255"
    echo "#define USHRT_MAX      65535"
    echo "#define UINT_MAX       0xffffffff"
    echo "#define ULONG_MAX      0xffffffffffffffffUL"
    echo "#define MAXFLOAT       FLT_MAX"
    echo "#define HUGE_VALF      __builtin_huge_valf()"
    echo "#define HUGE_VAL       __builtin_huge_val()"
    echo "#define INFINITY       __builtin_inff()"
    echo "#define NAN            nan((uint )0)"

    echo "#ifdef __CA_BUILTINS_HALF_SUPPORT"
    echo "#define M_E_H            0x1.5cp+1f16"
    echo "#define M_LOG2E_H        0x1.714p+0f16"
    echo "#define M_LOG10E_H       0x1.bccp-2f16"
    echo "#define M_LN2_H          0x1.63p-1f16"
    echo "#define M_LN10_H         0x1.26cp+1f16"
    echo "#define M_PI_H           0x1.92p+1f16"
    echo "#define M_PI_2_H         0x1.92p+0f16"
    echo "#define M_PI_4_H         0x1.92p-1f16"
    echo "#define M_1_PI_H         0x1.46p-2f16"
    echo "#define M_2_PI_H         0x1.46p-1f16"
    echo "#define M_2_SQRTPI_H     0x1.20cp+0f16"
    echo "#define M_SQRT2_H        0x1.6ap+0f16"
    echo "#define M_SQRT1_2_H      0x1.6ap-1f16"
    echo "#endif"

    echo "#define M_E_F          2.718281828459045235360287471352662497757247093699959574966967f"
    echo "#define M_LOG2E_F      1.442695040888963407359924681001892137426645954152985934135449f"
    echo "#define M_LOG10E_F     0.434294481903251827651128918916605082294397005803666566114453f"
    echo "#define M_LN2_F        0.693147180559945309417232121458176568075500134360255254120680f"
    echo "#define M_LN10_F       2.302585092994045684017991454684364207601101488628772976033327f"
    echo "#define M_PI_F         3.141592653589793238462643383279502884197169399375105820974944f"
    echo "#define M_PI_2_F       1.570796326794896619231321691639751442098584699687552910487472f"
    echo "#define M_PI_4_F       0.785398163397448309615660845819875721049292349843776455243736f"
    echo "#define M_1_PI_F       0.318309886183790671537767526745028724068919291480912897495334f"
    echo "#define M_2_PI_F       0.636619772367581343075535053490057448137838582961825794990669f"
    echo "#define M_2_SQRTPI_F   1.128379167095512573896158903121545171688101258657997713688171f"
    echo "#define M_SQRT2_F      1.414213562373095048801688724209698078569671875376948073176679f"
    echo "#define M_SQRT1_2_F    0.707106781186547524400844362104849039284835937688474036588339f"

    echo "#ifdef __CA_BUILTINS_DOUBLE_SUPPORT"
    echo "#define M_E            0x1.5bf0a8b145769p+1"
    echo "#define M_LOG2E        0x1.71547652b82fep+0"
    echo "#define M_LOG10E       0x1.bcb7b1526e50ep-2"
    echo "#define M_LN2          0x1.62e42fefa39efp-1"
    echo "#define M_LN10         0x1.26bb1bbb55516p+1"
    echo "#define M_PI           0x1.921fb54442d18p+1"
    echo "#define M_PI_2         0x1.921fb54442d18p+0"
    echo "#define M_PI_4         0x1.921fb54442d18p-1"
    echo "#define M_1_PI         0x1.45f306dc9c883p-2"
    echo "#define M_2_PI         0x1.45f306dc9c883p-1"
    echo "#define M_2_SQRTPI     0x1.20dd750429b6dp+0"
    echo "#define M_SQRT2        0x1.6a09e667f3bcdp+0"
    echo "#define M_SQRT1_2      0x1.6a09e667f3bcdp-1"
    echo "#endif // __CA_BUILTINS_DOUBLE_SUPPORT"

    echo "#define FP_ILOGB0      INT_MIN"
    echo "#define FP_ILOGBNAN    INT_MAX"

    echo "typedef uint cl_mem_fence_flags;"
    echo "#define CLK_LOCAL_MEM_FENCE  1u"
    echo "#define CLK_GLOBAL_MEM_FENCE 2u"
  fi
}

function as_type()
{
  local retType=$1
  local argType=$2

  local body=";"
  if [[ "cl" == "$generated_output_type" ]]
  then
    body="{ return __builtin_astype(arg, $retType); }"
  fi

  echo "$retType __CL_CONST_ATTRIBUTES __attribute__((always_inline)) as_$retType($argType arg) $body"
}

function as_type_list()
{
  local i
  local k
  for i in $@
  do
    half_support_begin $i
    double_support_begin $i
    for k in $@
    do
      if [[ "$i" != "$k" ]]
      then
        half_support_begin $k
        double_support_begin $k

        as_type $i $k

        double_support_end $k
        half_support_end $k
      fi
    done
    double_support_end $i
    half_support_end $i
  done
}

function all_as_type()
{
  as_type_list char uchar
  as_type_list char2 uchar2 short ushort half
  as_type_list char4 uchar4 short2 ushort2 half2 int uint float
  as_type_list char8 uchar8 short4 ushort4 half4 int2 uint2 float2 long ulong double
  as_type_list char16 uchar16 short8 ushort8 half8 int4 uint4 float4 long2 ulong2 double2
  as_type_list short16 ushort16 half16 int8 uint8 float8 long4 ulong4 double4
  as_type_list int16 uint16 float16 long8 ulong8 double8
  as_type_list long16 ulong16 double16

  as_type_list char3 uchar3

  local i
  local k

  for i in char3 uchar3
  do
    for k in char4 uchar4
    do
      as_type_list $i $k
    done
  done

  as_type_list short3 ushort3 half3

  for i in short3 ushort3 half3
  do
    for k in short4 ushort4 half4
    do
      as_type_list $i $k
    done
  done

  as_type_list int3 uint3 float3

  for i in int3 uint3 float3
  do
    for k in int4 uint4 float4
    do
      as_type_list $i $k
    done
  done

  as_type_list long3 ulong3 double3

  for i in long3 ulong3 double3
  do
    for k in long4 ulong4 double4
    do
      as_type_list $i $k
    done
  done
}

function convert_type()
{
  local retType=$1
  local argType=$2
  local size=$3
  local saturate=$4
  local rounding=$5

  local modifiers=""

  if [[ true == $saturate ]]
  then
    modifiers="_sat"
  fi

  if [[ "" != $rounding ]]
  then
    modifiers=$modifiers"_"$rounding
  fi

  if [[ "1" != "$size" ]]
  then
    retType=$retType$size
    argType=$argType$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::convert<"

    if [[ true == $saturate ]]
    then
      body=$body"true"
    else
      body=$body"false"
    fi

    body=$body", "

    if [[ "" == $rounding ]]
    then
      body=$body"ocl::Rounding::undefined"
    else
      body=$body"ocl::Rounding::"$rounding
    fi

    body=$body", $retType>(arg); }"
  fi

  echo "$retType __CL_CONST_ATTRIBUTES convert_$retType$modifiers($argType arg) $body"
}

function all_convert_type()
{
  for i in $alltypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $alltypes
    do
      half_support_begin $k
      double_support_begin $k
      for size in $sizes
      do
        convert_type $i $k $size false
        convert_type $i $k $size true
        for m in $roundingmodes
        do
          convert_type $i $k $size false $m
          convert_type $i $k $size true $m
        done
      done
      double_support_end $k
      half_support_end $k
    done
    double_support_end $i
    half_support_end $i
  done
}

# Conversions to/from half are handled separately from all other conversion
# functions as the C++ part of the builtins has no notion of a half data-type,
# and even the OpenCL-C parts would require the cl_khr_fp16 extension to be
# enabled to use them in a practical sense.
function convert_half_type()
{
  local retType=$1
  local retTypeName=$2
  local argType=$3
  local argTypeName=$4
  local size=$5
  local rounding=$6

  local modifiers=""
  local argTypeSize=$argType
  if [[ "" != $rounding ]]
  then
    modifiers="_$rounding"
  fi

  if [[ "1" != "$size" ]]
  then
    retType=$retType$size
    argTypeSize=$argType$size
    retTypeName=$retTypeName$size
    argTypeName=$argTypeName$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::half_convert<"

    if [[ "" == $rounding ]]
    then
      body=$body"ocl::Rounding::undefined"
    else
      body=$body"ocl::Rounding::"$rounding
    fi

    body=$body", $retType>(arg); }"
  fi

  double_support_begin $retType
  double_support_begin $argType
  echo "$retType __CL_CONST_ATTRIBUTES convert_${argTypeName}_to_$retTypeName$modifiers($argTypeSize arg) $body"
  double_support_end $argType
  double_support_end $retType
}

function all_convert_half_type()
{
  for size in $sizes
  do
    # Convert a type/type to a type/type.  Each type must be listed
    # twice as half can (and must) be used as a parameter type, but
    # is not allowed to be used within functions (unless
    # cl_khr_fp16 is supported, and requiring fp16 support to
    # support fp16 is not sensible).  Thus we use ushort in its
    # place, as it has the same size as half.

    # Round half->float and float->half for default rounding mode.
    convert_half_type float float ushort half $size
    convert_half_type double double ushort half $size
    convert_half_type ushort half float float $size
    convert_half_type ushort half double double $size

    for m in $roundingmodes
    do
      # Convert float->half for each explicit rounding mode.
      # There are no explicit half->float rounding modes.
      convert_half_type ushort half float float $size $m
      convert_half_type ushort half double double $size $m
    done
  done
}

function all_vload()
{
  for i in $alltypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $addresses
    do
      for m in 2 3 4 8 16
      do
        local body=";"
        if [[ "cl" == "$generated_output_type" ]]
        then
            if [[ "3" == "$m" ]]
            then
              body="{ const $k $i * pO = pointer + (offset * $m); $i$m data; data.x = pO[0]; data.y = pO[1]; data.z = pO[2]; return data; }"
            else
              body="{ typedef $i$m unaligned_type __attribute__((aligned(sizeof($i)))); return *($k unaligned_type * )(pointer + (offset * $m)); }"
            fi
        fi

        if [[ "cxx" != "$generated_output_type" ]]
        then
          cxx_unsafe_begin
          echo "$i$m __CL_BUILTIN_ATTRIBUTES vload$m(size_t offset, const $k $i * pointer) $body"
          cxx_unsafe_end
        fi
      done
    done
    half_support_end $i
    double_support_end $i
  done
}

function all_vstore()
{
  for i in $alltypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $nonconstantaddresses
    do
      for m in 2 3 4 8 16
      do
        local body=";"
        if [[ "cl" == "$generated_output_type" ]]
        then
            if [[ "3" == "$m" ]]
            then
              body="{ $k $i * pO = pointer + (offset * $m); pO[0] = payload.x; pO[1] = payload.y; pO[2] = payload.z; }"
            else
              body="{ typedef $i$m unaligned_type __attribute__((aligned(sizeof($i)))); *($k unaligned_type * )(pointer + (offset * $m)) = payload; }"
            fi
        fi

        if [[ "cxx" != "$generated_output_type" ]]
        then
          cxx_unsafe_begin
          echo "void __CL_BUILTIN_ATTRIBUTES vstore$m($i$m payload, size_t offset, $k $i * pointer) $body"
          cxx_unsafe_end
        fi
      done
    done
    double_support_end $i
    half_support_end $i
  done
}

function all_vload_half()
{
  for suffix in "" a
  do
    for j in $addresses
    do
      for k in "" 2 3 4 8 16
      do
        # vload_halfn functions only require 2-byte
        # alignment, vloada_halfn require sizeof(halfn)
        # alignment, except for vloada_half3 which
        # requires sizeof(half4) alignment.  We use
        # ushort[n] in place of half[n] as it has the
        # same size.
        local align=ushort
        [[ "a" == "$suffix" ]] && align=ushort$k
        [[ "a" == "$suffix" ]] && [[ "3" == "$k" ]] && align=ushort4

        # Most address calculations are based on
        # multiplying the offset by $k words, except
        # for vloada_half3 which as a special case uses
        # 4-words (despite operating on half3 values).
        local n=$k
        [[ "" == "$k" ]] && n=1
        [[ "a" == "$suffix" ]] && [[ "3" == "$k" ]] && n=4

        local body=";"
        if [[ "cl" == "$generated_output_type" ]]
        then
          body="{\n"
          body+="#ifdef __CA_BUILTINS_HALF_SUPPORT\n"
          body+="typedef half${k} unaligned_type __attribute__((aligned(sizeof(${align}))));\n"
          body+="#else\n"
          body+="typedef ushort${k} unaligned_type __attribute__((aligned(sizeof(${align}))));\n"
          body+="#endif  // __CA_BUILTINS_HALF_SUPPORT\n"

          body+="const ${j} unaligned_type *p = (const ${j} unaligned_type *)(pointer + (offset * ${n}));\n"
          if [[ "3" != "$k" ]] ; then
            body+="unaligned_type t = *p;\n"
          else
            body+="unaligned_type t; t.x = p->x; t.y = p->y; t.z = p->z;\n"
          fi
          body+="#ifdef __CA_BUILTINS_HALF_SUPPORT\n"
          body+="if (__abacus_isftz() && !__abacus_isembeddedprofile()) {\n"
          body+="  return convert_half${k}_to_float${k}(as_ushort${k}(t));\n"
          body+="} else {\n"
          body+="  return convert_float${k}(t);\n"
          body+="}\n"
          body+="#else\n"
          body+="return convert_half${k}_to_float${k}(t);\n"
          body+="#endif  // __CA_BUILTINS_HALF_SUPPORT\n"
          body+="}\n"
        fi

        if [[ "cxx" != "$generated_output_type" ]]
        then
          echo -e "float${k} __CL_BUILTIN_ATTRIBUTES vload${suffix}_half${k}(size_t offset, const ${j} half * pointer) ${body}"
        fi
      done
    done
  done
}

function one_vstore_half {
  local suffix=$1
  local typ=$2
  local address=$3
  local size=$4
  local roundingmode=$5

  # vstore_halfn functions only require 2-byte alignment, vstorea_halfn
  # require sizeof(halfn) alignment, except for vstorea_half3 which
  # requires sizeof(half4) alignment.  We use ushort[n] in place of
  # half[n] as it has the same size.
  local align=ushort
  [[ "a" == "$suffix" ]] && align=ushort$size
  [[ "a" == "$suffix" ]] && [[ "3" == "$size" ]] && align=ushort4

  # Most address calculations are based on multiplying the offset by
  # $size words, except for vstorea_half3 which as a special case uses
  # 4-words (despite operating on half3 values).
  local n=$size
  [[ "" == "$size" ]] && n=1
  [[ "a" == "$suffix" ]] && [[ "3" == "$size" ]] && n=4

  local body=";"
  if [[ "cl" == "$generated_output_type" ]]
  then
    body="{\n"
    body+="#ifdef __CA_BUILTINS_HALF_SUPPORT\n"
    body+=" half${size} converted;\n"
    body+="if (__abacus_isftz() && !__abacus_isembeddedprofile()) {\n"
    body+="  ushort${size} soft_convert = convert_${typ}${size}_to_half${size}${roundingmode}(data);\n"
    body+="  converted = as_half${size}(soft_convert);\n"
    body+="} else {\n"
    body+="  converted = convert_half${size}${roundingmode}(data);\n"
    body+="}\n"
    body+="typedef half${size} unaligned_type __attribute__((aligned(sizeof(half))));\n"
    body+="#else\n"
    body+="  typedef ushort${size} unaligned_type __attribute__((aligned(sizeof(${align}))));\n"
    body+="  ushort${size} converted = convert_${typ}${size}_to_half${size}${roundingmode}(data);\n"
    body+="#endif  // __CA_BUILTINS_HALF_SUPPORT\n"
    body+="${address} unaligned_type *p = (${address} unaligned_type *)(pointer + (offset *${n}));\n"

    if [[ "3" != "$size" ]] ; then
      body+="  *p = converted;\n"
    else
      body+="  p->x = converted.x; p->y = converted.y; p->z = converted.z;\n"
    fi
    body+="}\n"
  fi

  if [[ "cxx" != "$generated_output_type" ]]
  then
    echo -e "void __CL_BUILTIN_ATTRIBUTES vstore${suffix}_half${size}${roundingmode}(${typ}${size} data, size_t offset, ${address} half * pointer) ${body}"
  fi
}

function all_vstore_half()
{
  for suffix in "" a
  do
    for i in $floattypes
    do
      if [[ "$i" == "half" ]]
      then
        continue
      fi

      double_support_begin $i
      for j in $nonconstantaddresses
      do
        for k in "" 2 3 4 8 16
        do
          one_vstore_half "$suffix" $i $j "$k" ""
          for m in $roundingmodes
          do
            one_vstore_half "$suffix" $i $j "$k" _$m
          done
        done
      done
      double_support_end $i
    done
  done
}

function abs_abs_diff()
{
  local type=$1
  local size=$2

  if [[ "1" != "$size" ]]
  then
    type=$type$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::abs(x); }"
  fi

  echo "u$type __CL_CONST_ATTRIBUTES abs($type x) $body"
  echo "u$type __CL_CONST_ATTRIBUTES abs(u$type x) $body"

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::abs_diff(x, y); }"
  fi

  echo "u$type __CL_CONST_ATTRIBUTES abs_diff($type x, $type y) $body"
  echo "u$type __CL_CONST_ATTRIBUTES abs_diff(u$type x, u$type y) $body"
}

function all_abs_abs_diff()
{
  for i in $signedinttypes
  do
    for k in $sizes
    do
      abs_abs_diff $i $k
    done
  done
}

function int_with_scalars()
{
  local type=$1
  local size=$2

  local fulltype=$type

  if [[ "1" != "$size" ]]
  then
    fulltype=$fulltype$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::max(x, y); }"
  fi

  echo "$fulltype __CL_CONST_ATTRIBUTES max($fulltype x, $type y) $body"

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::min(x, y); }"
  fi

  echo "$fulltype __CL_CONST_ATTRIBUTES min($fulltype x, $type y) $body"

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::clamp(x, y, z); }"
  fi

  echo "$fulltype __CL_CONST_ATTRIBUTES clamp($fulltype x, $type y, $type z) $body"
}

function all_int_with_scalars()
{
  for i in $inttypes
  do
    for k in 2 3 4 8 16
    do
      int_with_scalars $i $k
    done
  done
}

function int_with_one_arg()
{
  local type=$1
  local size=$2

  if [[ "1" != "$size" ]]
  then
    type=$type$size
  fi

  for func in clz popcount
  do
    local body=";"

    echo "$type __CL_CONST_ATTRIBUTES $func($type x) $body"
  done
}

function all_int_with_one_arg()
{
  for i in $inttypes
  do
    for k in $sizes
    do
      int_with_one_arg $i $k
    done
  done
}

function int_with_two_args()
{
  local type=$1
  local size=$2

  if [[ "1" != "$size" ]]
  then
    type=$type$size
  fi

  for func in add_sat hadd rhadd mul_hi rotate sub_sat max min
  do
    local body=";"
    if [[ "cxx" == "$generated_output_type" ]]
    then
      body="{ return ocl::$func(x, y); }"
    fi

    echo "$type __CL_CONST_ATTRIBUTES $func($type x, $type y) $body"
  done
}

function all_int_with_two_args()
{
  for i in $inttypes
  do
    for k in $sizes
    do
      int_with_two_args $i $k
    done
  done
}

function int_with_three_args()
{
  local type=$1
  local size=$2

  if [[ "1" != "$size" ]]
  then
    type=$type$size
  fi

  for func in mad_hi mad_sat clamp
  do
    local body=";"
    if [[ "cxx" == "$generated_output_type" ]]
    then
      body="{ return ocl::$func(x, y, z); }"
    fi

    echo "$type __CL_CONST_ATTRIBUTES $func($type x, $type y, $type z) $body"
  done
}

function all_int_with_three_args()
{
  for i in $inttypes
  do
    for k in $sizes
    do
      int_with_three_args $i $k
    done
  done
}

function mul24()
{
  local types="int uint"
  for i in $types
  do
    for k in $sizes
    do
      if [[ "1" != "$k" ]]
      then
        type=$i$k
      else
        type=$i
      fi

      local body=";"
      if [[ "cxx" == "$generated_output_type" ]]
      then
        body="{ return ocl::mul24(x, y); }"
      fi

      echo "$type __CL_CONST_ATTRIBUTES mul24($type x, $type y) $body"
    done
  done
}

function mad24()
{
  local types="int uint"
  for i in $types
  do
    for k in $sizes
    do
      if [[ "1" != "$k" ]]
      then
        type=$i$k
      else
        type=$i
      fi

      local body=";"
      if [[ "cxx" == "$generated_output_type" ]]
      then
        body="{ return ocl::mad24(x, y, z); }"
      fi

      echo "$type __CL_CONST_ATTRIBUTES mad24($type x, $type y, $type z) $body"
    done
  done
}

function upsample()
{
  local largetype=$1
  local smalltype=$2
  local size=$3

  if [[ "1" != "$size" ]]
  then
    largetype=$largetype$size
    smalltype=$smalltype$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::upsample<$largetype>(x, y); }"
  fi

  echo "$largetype __CL_CONST_ATTRIBUTES upsample($smalltype x, u$smalltype y) $body"

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::upsample<u$largetype>(x, y); }"
  fi

  echo "u$largetype __CL_CONST_ATTRIBUTES upsample(u$smalltype x, u$smalltype y) $body"
}

function all_upsample()
{
  for i in $sizes
  do
    upsample short char $i
    upsample int short $i
    upsample long int $i
  done
}

function relational_with_one_arg()
{
  local name=$1
  local type=$2
  local size=$3

  local returnType="int"
  [[ "double" == "$type" ]] && [[ "1" != "$size" ]] && returnType="long"
  [[ "half" == "$type" ]] && [[ "1" != "$size" ]] && returnType="short"

  if [[ "1" != "$size" ]]
  then
    type=$type$size
    returnType=$returnType$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::$name(x); }"
  fi

  echo "$returnType __CL_CONST_ATTRIBUTES $name($type x) $body"
}

function all_relational_with_one_arg()
{
  for i in isfinite isinf isnan isnormal signbit
  do
    for k in $floattypes
    do
      half_support_begin $k
      double_support_begin $k
      for m in $sizes
      do
        relational_with_one_arg $i $k $m
      done
      half_support_end $k
      double_support_end $k
    done
  done
}

function relational_with_two_args()
{
  local name=$1
  local type=$2
  local size=$3

  local returnType="int"
  [[ "double" == "$type" ]] && [[ "1" != "$size" ]] && returnType="long"
  [[ "half" == "$type" ]] && [[ "1" != "$size" ]] && returnType="short"

  if [[ "1" != "$size" ]]
  then
    type=$type$size
    returnType=$returnType$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::$name(x, y); }"
  fi

  echo "$returnType __CL_CONST_ATTRIBUTES $name($type x, $type y) $body"
}

function all_relational_with_two_args()
{
  for i in isequal isnotequal isgreater isgreaterequal isless islessequal islessgreater isordered isunordered
  do
    for k in $floattypes
    do
      half_support_begin $k
      double_support_begin $k
      for m in $sizes
      do
        relational_with_two_args $i $k $m
      done
      double_support_end $k
      half_support_end $k
    done
  done
}

function relational_with_three_args()
{
  local name=$1
  local type=$2
  local size=$3

  if [[ "1" != "$size" ]]
  then
    type=$type$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::$name(x, y, z); }"
  fi

  echo "$type __CL_CONST_ATTRIBUTES $name($type x, $type y, $type z) $body"
}

function all_relational_with_three_args()
{
  for i in bitselect
  do
    for k in $alltypes
    do
      half_support_begin $k
      double_support_begin $k
      for m in $sizes
      do
        relational_with_three_args $i $k $m
      done
      double_support_end $k
      half_support_end $k
    done
  done
}

function relational_any_all()
{
  local name=$1
  local type=$2
  local size=$3

  if [[ "1" != "$size" ]]
  then
    type=$type$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::$name(x); }"
  fi

  echo "int __CL_CONST_ATTRIBUTES $name($type x) $body"
}

function all_relational_any_all()
{
  for i in any all
  do
    for k in $signedinttypes
    do
      for m in $sizes
      do
        relational_any_all $i $k $m
      done
    done
  done
}

function a_select()
{
  local type=$1
  local comparetype=$2
  local size=$3

  if [[ "1" != "$size" ]]
  then
    type=$type$size
    comparetype=$comparetype$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::select(x, y, z); }"
  fi

  echo "$type __CL_CONST_ATTRIBUTES select($type x, $type y, $comparetype z) $body"
}

function all_select()
{
  for i in $signedinttypes
  do
    for k in $sizes
    do
      a_select $i $i $k
      a_select $i u$i $k
      a_select u$i $i $k
      a_select u$i u$i $k
    done
  done

  for k in $sizes
  do
    half_support_begin half
    a_select half short $k
    a_select half ushort $k
    half_support_end half

    a_select float int $k
    a_select float uint $k
    double_support_begin double
    a_select double long $k
    a_select double ulong $k
    double_support_end double
  done
}

function a_shuffle()
{
  local inputType=$1
  local inputSize=$2
  local maskType=$3
  local maskSize=$4

  local outputType=$inputType

  if [[ "1" != "$inputSize" ]]
  then
    inputType=$inputType$inputSize
  fi

  if [[ "1" != "$maskSize" ]]
  then
    maskType=$maskType$maskSize
    outputType=$outputType$maskSize
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::shuffle<$outputType>(x, m); }"
  fi

  echo "$outputType __CL_CONST_ATTRIBUTES shuffle($inputType x, $maskType m) $body"
}

function all_shuffle()
{
  local shuffleSizes="2 4 8 16"

  for i in $signedinttypes
  do
    for k in $shuffleSizes
    do
      for m in $shuffleSizes
      do
        a_shuffle $i $k u$i $m
        a_shuffle u$i $k u$i $m
      done
    done
  done

  for k in $shuffleSizes
  do
    for m in $shuffleSizes
    do
      half_support_begin half
      a_shuffle half $k ushort $m
      half_support_end half
      a_shuffle float $k uint $m
      double_support_begin double
      a_shuffle double $k ulong $m
      double_support_end double
    done
  done
}

function a_shuffle2()
{
  local inputType=$1
  local inputSize=$2
  local maskType=$3
  local maskSize=$4

  local outputType=$inputType

  if [[ "1" != "$inputSize" ]]
  then
    inputType=$inputType$inputSize
  fi

  if [[ "1" != "$maskSize" ]]
  then
    maskType=$maskType$maskSize
    outputType=$outputType$maskSize
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::shuffle2<$outputType>(x, y, m); }"
  fi

  echo "$outputType __CL_CONST_ATTRIBUTES shuffle2($inputType x, $inputType y, $maskType m) $body"
}

function all_shuffle2()
{
  local shuffleSizes="2 4 8 16"
  for i in $signedinttypes
  do
    for k in $shuffleSizes
    do
      for m in $shuffleSizes
      do
        a_shuffle2 $i $k u$i $m
        a_shuffle2 u$i $k u$i $m
      done
    done
  done

  for k in $shuffleSizes
  do
    for m in $shuffleSizes
    do
      half_support_begin half
      a_shuffle2 half $k ushort $m
      half_support_end half
      a_shuffle2 float $k uint $m
      double_support_begin double
      a_shuffle2 double $k ulong $m
      double_support_end double
    done
  done
}

function a_atomic_one_arg()
{
  local type=$1
  local address_space=$2
  local name=$3

  local body=";"

  echo "$type __CL_BUILTIN_ATTRIBUTES $name(volatile $type $address_space * p) $body"
}

function all_atomic_one_arg()
{
  for i in int long uint ulong
  do
    for k in global local
    do
      for m in atomic_dec atomic_inc atom_dec atom_inc
      do
        [[ $m = atomic_* && $i = *long ]] && continue
        a_atomic_one_arg $i $k $m
      done
    done
  done
}

function a_atomic_two_args()
{
  local type=$1
  local address_space=$2
  local name=$3


  local prefix=""
  local body=";"

  echo "$prefix$type __CL_BUILTIN_ATTRIBUTES $name(volatile $type $address_space * p, $type val) $body"
}

function a_atomic_two_args_for_float()
{
  local type=$1
  local address_space=$2
  local name=$3

  local body=";"

  echo "$type __CL_BUILTIN_ATTRIBUTES $name(volatile $type $address_space * p, $type val) $body"
}

function all_atomic_two_args()
{
  for i in int long uint ulong
  do
    for k in global local
    do
      for m in atomic_add atomic_sub atomic_xchg atomic_min atomic_max atomic_and atomic_or atomic_xor atom_add atom_sub atom_xchg atom_min atom_max atom_and atom_or atom_xor
      do
        [[ $m = atomic_* && $i = *long ]] && continue
        a_atomic_two_args $i $k $m
      done
    done
  done

  a_atomic_two_args_for_float float global atomic_xchg
  a_atomic_two_args_for_float float global atom_xchg
  a_atomic_two_args_for_float float local atomic_xchg
  a_atomic_two_args_for_float float local atom_xchg
}

function a_atomic_three_args()
{
  local type=$1
  local address_space=$2
  local name=$3

  local body=";"

  echo "$type __CL_BUILTIN_ATTRIBUTES $name(volatile $type $address_space * p, $type cmp, $type val) $body"
}

function all_atomic_three_args()
{
  for i in int long uint ulong
  do
    for k in global local
    do
      for m in atomic_cmpxchg atom_cmpxchg
      do
        [[ $m = atomic_* && $i = *long ]] && continue
        a_atomic_three_args $i $k $m
      done
    done
  done
}

function a_barrier()
{
  local name=$1

  local attribute="";
  local attributes="__CL_BUILTIN_ATTRIBUTES";
  [[ "barrier" == "$name" ]] && attributes="__CL_BARRIER_ATTRIBUTES"

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    # Do not define barrier, otherwise it will get inlined to
    # nothing before we can record the fact that barriers are used
    # in a kernel.
    [[ "barrier" == "$name" ]] && body="/* See generate_header.sh */ ;"
    [[ "mem_fence" == "$name" ]] && body="{ __c11_atomic_signal_fence(__ATOMIC_ACQ_REL); }"
    [[ "read_mem_fence" == "$name" ]] && body="{ __c11_atomic_signal_fence(__ATOMIC_ACQUIRE); }"
    [[ "write_mem_fence" == "$name" ]] && body="{ __c11_atomic_signal_fence(__ATOMIC_RELEASE); }"
    [[ "barrier" != "$name" ]] && attribute=" __attribute__((unused))"
  fi

  echo "void $attributes $name(cl_mem_fence_flags flags$attribute) $body"
}

function all_barrier()
{
  if [[ "cxx" == "$generated_output_type" ]]
  then
    echo '// Much like other parts of this file we exploit the fact that we'
    echo '// know we are compiling with Clang and choose builtins that will'
    echo '// map directly to LLVM IR. These fences will affect the compiler'
    echo '// only, they should not result any extra instructions being'
    echo '// generated as they map to an LLVM IR fence instruction with'
    echo '// syncscope("singlethread").  __c11_atomic_thread_fence could be'
    echo '// used instead, that would likely require extra instructions to be'
    echo '// generated to implement the fence, and to some extent makes sense.'
    echo '// However, it does not really match OpenCL semantics, e.g. it would'
    echo '// synchronize the whole system not just a work-group and can not'
    echo '// differentiate between local and global memory.  As the fence'
    echo '// property of barriers is implemented as a compiler pass, if the'
    echo '// scope of fences change here they should also change within that'
    echo '// pass (PassReplaceBarriers in the OpenCL runtime).'
  fi
  for i in barrier mem_fence read_mem_fence write_mem_fence
  do
    a_barrier $i
  done
}

function a_work_item_builtins()
{
  local name=$1

  local body=";"

  echo "size_t __CL_WORK_ITEM_ATTRIBUTES $name(uint x) $body"
}

function all_work_item_builtins()
{
  for i in get_global_size get_global_id get_local_size get_local_id get_num_groups get_group_id get_global_offset
  do
    a_work_item_builtins $i
  done

  echo "uint __CL_WORK_ITEM_ATTRIBUTES get_work_dim(void) ;"
}

function a_common_one_arg()
{
  local type=$1
  local size=$2
  local name=$3

  if [[ "1" != "$size" ]]
  then
    type=$type$size
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::$name(x); }"
  fi

  echo "$type __CL_CONST_ATTRIBUTES $name($type x) $body"
}

function all_common_one_arg()
{
  for i in $floattypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      for m in degrees radians sign
      do
        a_common_one_arg $i $k $m
      done
    done
    double_support_end $i
    half_support_end $i
  done
}

function a_common_two_args()
{
  local xtype=$1
  local xsize=$2
  local ytype=$3
  local ysize=$4
  local rtype=$5
  local rsize=$6
  local name=$7

  if [[ "1" != "$xsize" ]]
  then
    xtype=$xtype$xsize
  fi

  if [[ "1" != "$ysize" ]]
  then
    ytype=$ytype$ysize
  fi

  if [[ "1" != "$rsize" ]]
  then
    rtype=$rtype$rsize
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::$name(x, y); }"
  fi

  echo "$rtype __CL_CONST_ATTRIBUTES $name($xtype x, $ytype y) $body"
}

function all_common_two_args()
{
  for i in $floattypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      for m in max min step
      do
        if [[ "1" != "$k" ]]
        then
          if [[ "step" == "$m" ]]
          then
            a_common_two_args $i 1 $i $k $i $k $m
          else
            a_common_two_args $i $k $i 1 $i $k $m
          fi
        fi
        a_common_two_args $i $k $i $k $i $k $m
      done
    done
    double_support_end $i
    half_support_end $i
  done
}

function a_common_three_args()
{
  local xtype=$1
  local xsize=$2
  local ytype=$3
  local ysize=$4
  local ztype=$5
  local zsize=$6
  local rtype=$7
  local rsize=$8
  local name=$9

  if [[ "1" != "$xsize" ]]
  then
    xtype=$xtype$xsize
  fi

  if [[ "1" != "$ysize" ]]
  then
    ytype=$ytype$ysize
  fi

  if [[ "1" != "$zsize" ]]
  then
    ztype=$ztype$zsize
  fi

  if [[ "1" != "$rsize" ]]
  then
    rtype=$rtype$rsize
  fi

  local body=";"
  if [[ "cxx" == "$generated_output_type" ]]
  then
    body="{ return ocl::$name(x, y, z); }"
  fi

  echo "$rtype __CL_CONST_ATTRIBUTES $name($xtype x, $ytype y, $ztype z) $body"
}

function all_common_three_args()
{
  for i in $floattypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      for m in clamp mix smoothstep
      do
        if [[ "1" != "$k" ]]
        then
          if [[ "smoothstep" == "$m" ]]
          then
            a_common_three_args $i 1 $i 1 $i $k $i $k $m
          else
            a_common_three_args $i $k $i 1 $i 1 $i $k $m
          fi
        fi
        a_common_three_args $i $k $i $k $i $k $i $k $m
      done
    done
    double_support_end $i
    half_support_end $i
  done
}

function math_one_args()
{
  local type=$1
  local size=$2
  local matchingIntType=int
  local matchingSmallIntType=int
  [[ "double" == "$type" ]] && matchingIntType=long
  [[ "half" == "$type" ]] && matchingIntType=short

  if [[ "1" != "$size" ]]
  then
    type=$type$size
    matchingIntType=$matchingIntType$size
    matchingSmallIntType=$matchingSmallIntType$size
  fi

  for func in acos acosh acospi asin asinh asinpi atan atanh atanpi cbrt ceil cos half_cos native_cos cosh cospi erfc erf exp half_exp native_exp exp2 half_exp2 native_exp2 exp10 half_exp10 native_exp10 expm1 fabs floor lgamma log half_log native_log log2 half_log2 native_log2 log10 half_log10 native_log10 log1p logb rint round rsqrt half_rsqrt native_rsqrt sin half_sin native_sin sinh sinpi sqrt half_sqrt native_sqrt tan half_tan native_tan tanh tanpi tgamma trunc half_recip native_recip
  do
    # cl_khr_fp16 and cl_khr_fp64 extensions don't implement native_ or half_ maths builtins
    if [[ "$type" == "half"* || "$type" == "double"* ]]
    then
      if [[ "$func" == "native_"* ]] || [[ "$func" == "half_"* ]]
      then
        continue
      fi
    fi

    local body=";"

    if [[ "cl" == "$generated_output_type" ]]
    then
      body="{ return _Codeplay_$func(x); }"
    fi

    echo "$type __CL_CONST_ATTRIBUTES $func($type x) $body"
  done

  local body=";"

  if [[ "cl" == "$generated_output_type" ]]
  then
    body="{ return _Codeplay_ilogb(x); }"
  fi

  echo "$matchingSmallIntType __CL_CONST_ATTRIBUTES ilogb($type x) $body"

  local body=";"

  if [[ "cl" == "$generated_output_type" ]]
  then
    body="{ return _Codeplay_nan(x); }"
  fi

  echo "$type __CL_CONST_ATTRIBUTES nan(u$matchingIntType x) $body"
}

function all_math_one_args()
{
  for i in $floattypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      math_one_args $i $k
    done
    double_support_end $i
    half_support_end $i
  done
}

function math_two_args()
{
  local originalType=$1
  local type=$1
  local size=$2
  local matchingIntType=int
  local matchingSmallIntType=int
  [[ "double" == "$type" ]] && matchingIntType=long
  [[ "half" == "$type" ]] && matchingIntType=short

  if [[ "1" != "$size" ]]
  then
    type=$type$size
    matchingIntType=$matchingIntType$size
    matchingSmallIntType=$matchingSmallIntType$size
  fi

  for func in atan2 atan2pi copysign half_divide native_divide fdim fmax fmin fmod hypot maxmag minmag nextafter pow powr half_powr native_powr remainder
  do
    # cl_khr_fp16 and cl_khr_fp64 extensions don't implement native_ or half_ maths builtins
    if [[ "$type" == "half"* || "$type" == "double"* ]]
    then
      if [[ "$func" == "native_"* ]] || [[ "$func" == "half_"* ]]
      then
        continue
      fi
    fi

    local body=";"

    if [[ "cl" == "$generated_output_type" ]]
    then
      body="{ return _Codeplay_$func(x, y); }"
    fi

    echo "$type __CL_CONST_ATTRIBUTES $func($type x, $type y) $body"
  done

  if [[ "1" != "$size" ]]
  then
    for func in fmax fmin
    do
      local body=";"

      if [[ "cl" == "$generated_output_type" ]]
      then
        body="{ return _Codeplay_$func(x, y); }"
      fi

      echo "$type __CL_CONST_ATTRIBUTES $func($type x, $originalType y) $body"
    done
  fi

  for func in ldexp pown rootn
  do
    local body=";"

    if [[ "cl" == "$generated_output_type" ]]
    then
      body="{ return _Codeplay_$func(x, y); }"
    fi

    echo "$type __CL_CONST_ATTRIBUTES $func($type x, $matchingSmallIntType y) $body"
  done

  for address_space in $nonconstantaddresses
  do
    for func in fract modf sincos
    do
      local body=";"

      if [[ "cl" == "$generated_output_type" ]]
      then
        body="{ return _Codeplay_$func(x, y); }"
      fi

      echo "$type __CL_BUILTIN_ATTRIBUTES $func($type x, $address_space $type * y) $body"
    done

    for func in frexp lgamma_r
    do
      local body=";"

      if [[ "cl" == "$generated_output_type" ]]
      then
        body="{ return _Codeplay_$func(x, y); }"
      fi

      echo "$type __CL_BUILTIN_ATTRIBUTES $func($type x, $address_space $matchingSmallIntType * y) $body"
    done
  done
}

function all_math_two_args()
{
  for i in $floattypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      math_two_args $i $k
    done
    double_support_end $i
    half_support_end $i
  done
}

function math_three_args()
{
  local originalType=$1
  local type=$1
  local intType=int
  local size=$2

  if [[ "1" != "$size" ]]
  then
    type=$type$size
    intType=$intType$size
  fi

  for func in fma mad
  do
    local body=";"

    if [[ "cl" == "$generated_output_type" ]]
    then
      body="{ return _Codeplay_$func(x, y, z); }"
    fi

    echo "$type __CL_CONST_ATTRIBUTES $func($type x, $type y, $type z) $body"
  done

  for address_space in $nonconstantaddresses
  do
    for func in remquo
    do
      local body=";"

      if [[ "cl" == "$generated_output_type" ]]
      then
        body="{ return _Codeplay_$func(x, y, z); }"
      fi

      echo "$type __CL_BUILTIN_ATTRIBUTES $func($type x, $type y, $address_space $intType * z) $body"
    done
  done
}

function all_math_three_args()
{
  for i in $floattypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      math_three_args $i $k
    done
    double_support_end $i
    half_support_end $i
  done
}

function async_work_group_copy()
{
  if [[ "header" == "$generated_output_type" ]]
  then
    local type=$1
    local size=$2

    if [[ "1" != "$size" ]]
    then
      type=$type$size
    fi

    echo "event_t __CL_BARRIER_ATTRIBUTES async_work_group_copy(local $type * dst, const global $type * src, size_t num, event_t event);"
    echo "event_t __CL_BARRIER_ATTRIBUTES async_work_group_copy(global $type * dst, const local $type * src, size_t num, event_t event);"
  fi
}

function all_async_work_group_copy()
{
  for i in $alltypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      async_work_group_copy $i $k
    done
    double_support_end $i
    half_support_end $i
  done
}

function async_work_group_strided_copy()
{
  if [[ "header" == "$generated_output_type" ]]
    then
    local type=$1
    local size=$2

    if [[ "1" != "$size" ]]
    then
      type=$type$size
    fi

    echo "event_t __CL_BARRIER_ATTRIBUTES async_work_group_strided_copy(local $type * dst, const global $type * src, size_t num, size_t stride, event_t event);"


    echo "event_t __CL_BARRIER_ATTRIBUTES async_work_group_strided_copy(global $type * dst, const local $type * src, size_t num, size_t stride, event_t event);"
  fi
}

function all_async_work_group_strided_copy()
{
  for i in $alltypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      async_work_group_strided_copy $i $k
    done
    double_support_end $i
    half_support_end $i
  done
}

# the extended async copies differ from the regular async copy in that they take
# a void* pointer rather than gentype

function async_work_group_copy_2D2D()
{
  if [[ "header" == "$generated_output_type" ]]
  then
    echo "event_t __CL_BARRIER_ATTRIBUTES async_work_group_copy_2D2D(local void * dst, size_t dst_offset, const global void * src, size_t src_offset, size_t num_bytes_per_element, size_t num_elements_per_line, size_t num_lines, size_t src_total_line_length, size_t dst_total_line_length, event_t event);"
    echo "event_t __CL_BARRIER_ATTRIBUTES async_work_group_copy_2D2D(global void * dst, size_t dst_offset, const local void * src, size_t src_offset, size_t num_bytes_per_element, size_t num_elements_per_line, size_t num_lines, size_t src_total_line_length, size_t dst_total_line_length, event_t event);"
  fi
}

function async_work_group_copy_3D3D()
{
  if [[ "header" == "$generated_output_type" ]]
  then
    echo "event_t __CL_BARRIER_ATTRIBUTES async_work_group_copy_3D3D(local void * dst,size_t dst_offset,const global void * src,size_t src_offset,size_t num_bytes_per_element,size_t num_elements_per_line,size_t num_lines,size_t num_planes,size_t src_total_line_length,size_t src_total_plane_area,size_t dst_total_line_length,size_t dst_total_plane_area,event_t event);"
    echo "event_t __CL_BARRIER_ATTRIBUTES async_work_group_copy_3D3D(global void * dst,size_t dst_offset,const local void * src,size_t src_offset,size_t num_bytes_per_element,size_t num_elements_per_line,size_t num_lines,size_t num_planes,size_t src_total_line_length,size_t src_total_plane_area,size_t dst_total_line_length,size_t dst_total_plane_area,event_t event);"
  fi
}

function wait_group_events()
{
  if [[ "header" == "$generated_output_type" ]]
  then
    echo "void __CL_BARRIER_ATTRIBUTES wait_group_events(int num_events, event_t * event_list);"
  fi
}

function prefetch()
{
  local type=$1
  local size=$2

  if [[ "1" != "$size" ]]
  then
    type=$type$size
  fi

  local body=";"

  if [[ "cl" == "$generated_output_type" ]]
  then
    body="{}"
  fi

  echo "void __CL_BUILTIN_ATTRIBUTES prefetch(const global $type * pointer, size_t num) $body"
}

function all_prefetch()
{
  for i in $alltypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in $sizes
    do
      prefetch $i $k
    done
    double_support_end $i
    half_support_end $i
  done
}

function geometric_length()
{
  local body=";"
  for prefix in "" "fast_"
  do
    local func=$prefix"length"
    for type in $floattypes
    do
      half_support_begin $type
      double_support_begin $type
      for k in "" 2 3 4 8 16
      do
        if [[ "cxx" == "$generated_output_type" ]]
        then
          body="{ return ocl::$func(p); }"
        fi
        echo "$type __CL_CONST_ATTRIBUTES $func($type$k p) $body"
      done
      double_support_end $type
      half_support_end $type
    done
  done
}

function geometric_distance()
{
  local body=";"
  for prefix in "" "fast_"
  do
    local func=$prefix"distance"
    for type in $floattypes
    do
      half_support_begin $type
      double_support_begin $type
      for k in "" 2 3 4 8 16
      do
        if [[ "cxx" == "$generated_output_type" ]]
        then
          body="{ return ocl::$func(p0, p1); }"
        fi
        echo "$type __CL_CONST_ATTRIBUTES $func($type$k p0, $type$k p1) $body"
      done
      double_support_end $type
      half_support_end $type
    done
  done
}

function geometric_normalize()
{
  local body=";"
  for prefix in "" "fast_"
  do
    local func=$prefix"normalize"
    for type in $floattypes
    do
      half_support_begin $type
      double_support_begin $type
      for k in "" 2 3 4 8 16
      do
        if [[ "cxx" == "$generated_output_type" ]]
        then
          body="{ return ocl::$func(p); }"
        fi
        echo "$type$k __CL_CONST_ATTRIBUTES $func($type$k p) $body"
      done
      double_support_end $type
      half_support_end $type
    done
  done
}

function geometric_cross()
{
  local body=";"
  local func="cross"
  for type in $floattypes
  do
    double_support_begin $type
    half_support_begin $type
    for k in 3 4
    do
      if [[ "cxx" == "$generated_output_type" ]]
      then
        body="{ return ocl::$func(p0, p1); }"
      fi
      echo "$type$k __CL_CONST_ATTRIBUTES $func($type$k p0, $type$k p1) $body"
    done
    double_support_end $type
    half_support_end $type
  done
}

function geometric_dot()
{
  local body=";"
  local func="dot"
  for type in $floattypes
  do
    half_support_begin $type
    double_support_begin $type
    for k in "" 2 3 4
    do
      if [[ "cxx" == "$generated_output_type" ]]
      then
        body="{ return ocl::$func(p0, p1); }"
      fi
      echo "$type __CL_CONST_ATTRIBUTES $func($type$k p0, $type$k p1) $body"
    done
    double_support_end $type
    half_support_end $type
  done
}

function all_printf()
{
  echo "int __attribute__((weak)) printf(const constant char * const restrict fmt, ...) ;"
}

function generate_read_image() {
  local ret=$1
  local image=$2
  local dim=$3

  local suffix=""
  if [[ "$ret"  == "f"* ]]; then
    suffix="f"
  elif [[ "$ret" == "i"* ]]; then
    suffix="i"
  elif [[ "$ret" == "ui"* ]]; then
    suffix="ui"
  elif [[ "$ret" == "h"* ]]; then
    suffix="h"
  fi

  local body=";"

  if [[ "header" == "$generated_output_type" ]]; then
    if [[ "image1d_buffer_t" == "$image" ]]; then
      echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, int coord)$body"
    else
      if [[ 1 -eq $dim ]]; then
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, sampler_t sampler, int coord)$body"
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, sampler_t sampler, float coord)$body"
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, int coord)$body"
      elif [[ 2 -eq $dim ]]; then
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, sampler_t sampler, int2 coord)$body"
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, sampler_t sampler, float2 coord)$body"
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, int2 coord)$body"
      else
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, sampler_t sampler, int4 coord)$body"
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, sampler_t sampler, float4 coord)$body"
        echo "$ret __CL_CONST_ATTRIBUTES read_image$suffix(__read_only $image image, int4 coord)$body"
      fi
    fi
  fi
}

function generate_write_image() {
  local value=$1
  local image=$2
  local dim=$3

  local suffix=""
  if [[ "$value"  == "f"* ]]; then
    suffix="f"
  elif [[ "$value" == "i"* ]]; then
    suffix="i"
  elif [[ "$value" == "ui"* ]]; then
    suffix="ui"
  elif [[ "$value" == "h"* ]]; then
    suffix="h"
  fi

  local coord="int"
  if [[ 2 -eq $dim ]]; then
    coord="int2"
  elif [[ 3 -eq $dim ]]; then
    coord="int4"
  fi

  local body=";"

  if [[ "header" == "$generated_output_type" ]]; then
    echo "void __CL_BUILTIN_ATTRIBUTES write_image$suffix(__write_only $image image, $coord coord, $value color)$body"
  fi
}

function generate_get_image() {
  local image=$1
  local dim=$2
  local modifier=$3

  if [[ "header" == "$generated_output_type" ]]; then
    local ret="int"
    local body=";"

    echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_width($modifier $image image)$body"

    if [[ 2 -le $dim ]]; then
      if [[ "image1d_array_t" != "$image" ]]; then
        echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_height($modifier $image image)$body"
      fi
    fi

    if [[ "image3d_t" == "$image" ]]; then
      echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_depth($modifier $image image)$body"
    fi

    echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_channel_data_type($modifier $image image)$body"

    echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_channel_order($modifier $image image)$body"

    ret="int2"
    body=";"
    if [[ "image2d_t" == "$image" ]]; then
      echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_dim($modifier $image image)$body"
    elif [[ "image2d_array_t" == "$image" ]]; then
      echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_dim($modifier $image image)$body"
    elif [[ "image3d_t" == "$image" ]]; then
      ret="int4"
      body=";"
      echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_dim($modifier $image image)$body"
    fi

    ret="size_t"
    body=";"
    if [[ "$image" == *"array_t" ]]; then
      echo "$ret __CL_BUILTIN_ATTRIBUTES get_image_array_size($modifier $image image)$body"
    fi
  fi
}

function get_image_dim() {
  local image=$1
  local dim=1
  if [[ "image1d_t" == "$image" ]]; then
    echo 1
  elif [[ "image1d_buffer_t" == "$image" ]]; then
    echo 1
  elif [[ "image1d_array_t" == "$image" ]]; then
    echo 2
  elif [[ "image2d_t" == "$image" ]]; then
    echo 2
  elif [[ "image2d_array_t" == "$image" ]]; then
    echo 3
  elif [[ "image3d_t" == "$image" ]]; then
    echo 3
  fi
}

function all_image() {
  if [[ "header" == "$generated_output_type" ]]
  then
    echo "#ifdef __CODEPLAY_OCL_IMAGE_SUPPORT"
    echo "#define CLK_R 0x10B0"
    echo "#define CLK_A 0x10B1"
    echo "#define CLK_RG 0x10B2"
    echo "#define CLK_RA 0x10B3"
    echo "#define CLK_RGB 0x10B4"
    echo "#define CLK_RGBA 0x10B5"
    echo "#define CLK_BGRA 0x10B6"
    echo "#define CLK_ARGB 0x10B7"
    echo "#define CLK_INTENSITY 0x10B8"
    echo "#define CLK_LUMINANCE 0x10B9"
    echo "#define CLK_Rx 0x10BA"
    echo "#define CLK_RGx 0x10BB"
    echo "#define CLK_RGBx 0x10BC"
    echo "#define CLK_DEPTH 0x10BD"
    echo "#define CLK_DEPTH_STENCIL 0x10BE"
    echo "#define CLK_SNORM_INT8 0x10D0"
    echo "#define CLK_SNORM_INT16 0x10D1"
    echo "#define CLK_UNORM_INT8 0x10D2"
    echo "#define CLK_UNORM_INT16 0x10D3"
    echo "#define CLK_UNORM_SHORT_565 0x10D4"
    echo "#define CLK_UNORM_SHORT_555 0x10D5"
    echo "#define CLK_UNORM_INT_101010 0x10D6"
    echo "#define CLK_SIGNED_INT8 0x10D7"
    echo "#define CLK_SIGNED_INT16 0x10D8"
    echo "#define CLK_SIGNED_INT32 0x10D9"
    echo "#define CLK_UNSIGNED_INT8 0x10DA"
    echo "#define CLK_UNSIGNED_INT16 0x10DB"
    echo "#define CLK_UNSIGNED_INT32 0x10DC"
    echo "#define CLK_HALF_FLOAT 0x10DD"
    echo "#define CLK_FLOAT 0x10DE"
    echo "#define CLK_UNORM_INT24 0x10DF"
    echo "#define CLK_ADDRESS_NONE 0x0000"
    echo "#define CLK_ADDRESS_CLAMP_TO_EDGE 0x0002"
    echo "#define CLK_ADDRESS_CLAMP 0x0004"
    echo "#define CLK_ADDRESS_REPEAT 0x0006"
    echo "#define CLK_ADDRESS_MIRRORED_REPEAT 0x0008"
    echo "#define CLK_NORMALIZED_COORDS_FALSE 0x0000"
    echo "#define CLK_NORMALIZED_COORDS_TRUE 0x0001"
    echo "#define CLK_FILTER_NEAREST 0x0010"
    echo "#define CLK_FILTER_LINEAR 0x0020"
    echo "#define __IMAGE_SUPPORT__ 1"

    echo "#ifndef __cplusplus"
    echo "#pragma OPENCL EXTENSION cl_khr_3d_image_writes : enable"

    for value in float4 int4 uint4 half4
    do
      half_support_begin $value

      for image in image1d_t image1d_buffer_t image1d_array_t image2d_t image2d_array_t image3d_t
      do
        local dim=$(get_image_dim "$image")

        generate_read_image $value $image $dim
        generate_write_image $value $image $dim
      done

      half_support_end $value
    done

    for image in image1d_t image1d_buffer_t image1d_array_t image2d_t image2d_array_t image3d_t
    do
      local dim=$(get_image_dim "$image")
      generate_get_image $image $dim __read_only
      generate_get_image $image $dim __write_only
    done

    echo "#endif  // __cplusplus"
    echo "#endif  // __CODEPLAY_OCL_IMAGE_SUPPORT"
  fi
}

function all_extras()
{
  for i in $signedinttypes
  do
    for k in "" 2 3 4 8 16
    do
        for func in findLSB findMSB
        do
          echo "$i$k __CL_CONST_ATTRIBUTES $func($i$k x);"
          echo "$i$k __CL_CONST_ATTRIBUTES $func(u$i$k x);"
        done

        echo "$i$k __CL_CONST_ATTRIBUTES bitfieldReverse($i$k x);"
        echo "u$i$k __CL_CONST_ATTRIBUTES bitfieldReverse(u$i$k x);"
    done
  done

  for i in $floattypes
  do
    half_support_begin $i
    double_support_begin $i
    for k in "" 2 3 4
    do
      echo "$i$k __CL_CONST_ATTRIBUTES faceforward($i$k n, $i$k i, $i$k nref);"
      echo "$i$k __CL_CONST_ATTRIBUTES reflect($i$k n, $i$k i);"
      for l in "half" "float"
      do
        half_support_begin $l
        echo "$i$k __CL_CONST_ATTRIBUTES refract($i$k n, $i$k i, $l eta);"
        half_support_end $l
      done
      if [[ "$i" == "double" ]]
      then
        echo "$i$k __CL_CONST_ATTRIBUTES refract($i$k n, $i$k i, double eta);"
      fi
    done
    double_support_end $i
    half_support_end $i
  done

  echo "uint __CL_CONST_ATTRIBUTES packSnorm4x8(float4 x);"
  echo "uint __CL_CONST_ATTRIBUTES packUnorm4x8(float4 x);"
  echo "uint __CL_CONST_ATTRIBUTES packSnorm2x16(float2 x);"
  echo "uint __CL_CONST_ATTRIBUTES packUnorm2x16(float2 x) ;"
  echo "uint __CL_CONST_ATTRIBUTES packHalf2x16(float2 x);"
  echo "float4 __CL_CONST_ATTRIBUTES unpackSnorm4x8(uint x);"
  echo "float4 __CL_CONST_ATTRIBUTES unpackUnorm4x8(uint x);"
  echo "float2 __CL_CONST_ATTRIBUTES unpackSnorm2x16(uint x);"
  echo "float2 __CL_CONST_ATTRIBUTES unpackUnorm2x16(uint x);"
  echo "float2 __CL_CONST_ATTRIBUTES unpackHalf2x16(uint x);"
  echo "float __CL_CONST_ATTRIBUTES quantizeToF16(float x);"
  echo "float2 __CL_CONST_ATTRIBUTES quantizeToF16(float2 x);"
  echo "float3 __CL_CONST_ATTRIBUTES quantizeToF16(float3 x);"
  echo "float4 __CL_CONST_ATTRIBUTES quantizeToF16(float4 x);"
}

function quantize()
{
  for k in "" 2 3 4
  do
    echo "float$k __CL_CONST_ATTRIBUTES quantizeToF16(float$k x) {"
    echo "  return ocl::quantizeToF16<float$k>(x);"
    echo "}"
  done
}

function output_for_type()
{
  generated_output_type="$1"
  local outputFile="$2"
  echo -n "Generating: $1 $outputFile ... "

  header > "$outputFile"

  sand_line >> "$outputFile"

  all_typedefs >> "$outputFile"

  sand_line >> "$outputFile"

  [[ "cxx" != "$generated_output_type" ]] && all_as_type >> "$outputFile"

  sand_line >> "$outputFile"

  [[ "header" == "$generated_output_type" ]] && all_convert_type >> "$outputFile"
  all_convert_half_type >> "$outputFile"

  [[ "cxx" == "$generated_output_type" ]] && quantize >> "$outputFile"

  sand_line >> "$outputFile"

  [[ "header" == "$generated_output_type" ]] && all_vload >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_vstore >> "$outputFile"
  cxx_unsafe_begin >> "$outputFile"
  all_vload_half >> "$outputFile"
  all_vstore_half >> "$outputFile"
  cxx_unsafe_end >> "$outputFile"

  sand_line >> "$outputFile"

  # Integer Builtins
  [[ "header" == "$generated_output_type" ]] && all_abs_abs_diff >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_int_with_scalars >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_int_with_one_arg >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_int_with_two_args >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_int_with_three_args >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && mul24 >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && mad24 >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_upsample >> "$outputFile"

  sand_line >> "$outputFile"

    # Relational Builtins
  [[ "header" == "$generated_output_type" ]] && all_relational_with_one_arg >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_relational_with_two_args >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_relational_with_three_args >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_relational_any_all >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_select >> "$outputFile"

  sand_line >> "$outputFile"

  # Miscellaneous Vector Builtins
  [[ "header" == "$generated_output_type" ]] && all_shuffle >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_shuffle2 >> "$outputFile"

  sand_line >> "$outputFile"

  # Atomic Builtins
  all_atomic_one_arg >> "$outputFile"
  all_atomic_two_args >> "$outputFile"
  all_atomic_three_args >> "$outputFile"

  sand_line >> "$outputFile"

  # Synchronization Builtins
  all_barrier >> "$outputFile"

  sand_line >> "$outputFile"

  # Work Item Builtins
  all_work_item_builtins >> "$outputFile"

  sand_line >> "$outputFile"

  # Common Builtins
  [[ "header" == "$generated_output_type" ]] && all_common_one_arg >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_common_two_args >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_common_three_args >> "$outputFile"

  sand_line >> "$outputFile"

  # Math builtins
  [[ "header" == "$generated_output_type" ]] && all_math_one_args >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_math_two_args >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && all_math_three_args >> "$outputFile"

  sand_line >> "$outputFile"

  # Async builtins
  force_cxx_unsafe_begin >> "$outputFile"
  all_async_work_group_copy >> "$outputFile"
  all_async_work_group_strided_copy >> "$outputFile"
  async_work_group_copy_2D2D >> "$outputFile"
  async_work_group_copy_3D3D >> "$outputFile"
  wait_group_events >> "$outputFile"
  force_cxx_unsafe_end >> "$outputFile"
  all_prefetch >> "$outputFile"

  sand_line >> "$outputFile"

  # Geometric builtins
  [[ "header" == "$generated_output_type" ]] && geometric_length >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && geometric_distance >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && geometric_normalize >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && geometric_cross >> "$outputFile"
  [[ "header" == "$generated_output_type" ]] && geometric_dot >> "$outputFile"

  sand_line >> "$outputFile"

  # Printf builtins
  all_printf >> "$outputFile"

  sand_line >> "$outputFile"

  # Image builtins
  all_image >> "$outputFile"

  sand_line >> "$outputFile"

  # Extra builtins
  [[ "header" == "$generated_output_type" ]] && all_extras >> "$outputFile"

  sand_line >> "$outputFile"

  footer >> "$outputFile"

  check_bin "$CLANG_FORMAT" && "$CLANG_FORMAT" -style=file -i "$outputFile"

    echo "done."
}

scriptDir="$(cd $(dirname $0); pwd)"

# This version of clang-format used must match the version specified in the
# root CMakeLists.txt file, so scrape that.
CLANG_FORMAT_VERSION="$(cat "$scriptDir"/../../../../CMakeLists.txt \
  | grep 'find_package(ClangTools' \
  | head -n 1 \
  | sed -e 's/.*ClangTools \([0-9\.]*\) COMPONENTS.*/\1/')"
CLANG_FORMAT_LONG="clang-format-${CLANG_FORMAT_VERSION}"
CLANG_FORMAT_SHORT="clang-format-${CLANG_FORMAT_VERSION%.[0-9]}"
check_bin "$CLANG_FORMAT_LONG" && CLANG_FORMAT="$CLANG_FORMAT_LONG"
check_bin "$CLANG_FORMAT_SHORT" && CLANG_FORMAT="$CLANG_FORMAT_SHORT"
check_bin "$CLANG_FORMAT" \
  && echo "Using ${CLANG_FORMAT}." \
  || echo "Could not find ${CLANG_FORMAT_LONG} or ${CLANG_FORMAT_SHORT}."

output_for_type header "$scriptDir"/../include/builtins/builtins.h
output_for_type cl "$scriptDir"/../source/builtins.cl
output_for_type cxx "$scriptDir"/../source/builtins.cpp
